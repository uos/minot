#!/bin/sh
set -e

REPO="uos/minot"
INSTALL_DIR="${HOME}/.local/bin"
GITHUB_API="https://api.github.com/repos/${REPO}"
GITHUB_RELEASE="https://github.com/${REPO}/releases/download"
VERSION=""
FEATURES=""
EMBED_COMPONENTS=""
ROS_DISTRO=""
FORCE_BUILD=0
YES_TO_ALL=0
NO_DEFAULT_EMBED=0

RED=$(printf '\033[0;31m')
GREEN=$(printf '\033[0;32m')
YELLOW=$(printf '\033[1;33m')
BLUE=$(printf '\033[0;34m')
CYAN=$(printf '\033[0;36m')
BOLD=$(printf '\033[1m')
NC=$(printf '\033[0m') # No Color

info() {
    printf "${BLUE}${BOLD}>${NC} ${BOLD}%s${NC}\n" "$1"
}

success() {
    printf "${GREEN}${BOLD}${NC}${GREEN}%s${NC}\n" "$1"
}

warn() {
    printf "${YELLOW}${BOLD}${NC}${YELLOW}%s${NC}\n" "$1"
}

error() {
    printf "${RED}${BOLD}ERROR${NC} ${RED}%s${NC}\n" "$1" >&2
    exit 1
}

prompt() {
    printf "${CYAN}?${NC} %s " "$1"
}

write_uninstaller() {
    DEST_DIR="$1"
    BIN_DIR="$DEST_DIR"
    INSTALL_PREFIX=$(dirname "$BIN_DIR")
    LIB_DIR="${INSTALL_PREFIX}/lib"
    INCLUDE_DIR="${INSTALL_PREFIX}/include"

    UNINSTALL_PATH="${BIN_DIR}/minot-uninstall"
    cat >"${UNINSTALL_PATH}" <<'EOF'
#!/bin/sh
set -e

RED=$(printf '\033[0;31m')
GREEN=$(printf '\033[0;32m')
YELLOW=$(printf '\033[1;33m')
BLUE=$(printf '\033[0;34m')
BOLD=$(printf '\033[1m')
NC=$(printf '\033[0m')

info() { printf "${BLUE}${BOLD}>${NC} ${BOLD}%s${NC}\n" "$1"; }
success() { printf "${GREEN}${BOLD}${NC}${GREEN}%s${NC}\n" "$1"; }
warn() { printf "${YELLOW}${BOLD}${NC}${YELLOW}%s${NC}\n" "$1"; }
error() { printf "${RED}${BOLD}${NC}${RED}%s${NC}\n" "$1" >&2; exit 1; }
prompt() { printf "${BLUE}?${NC} %s " "$1"; }

# Check for -y/--yes flag for non-interactive mode
SKIP_PROMPT=0
if [ "$1" = "-y" ] || [ "$1" = "--yes" ]; then
    SKIP_PROMPT=1
fi

# Resolve where this uninstaller lives to infer install prefix
SELF="$0"
BIN_DIR=$(dirname "$SELF")
INSTALL_PREFIX=$(dirname "$BIN_DIR")
LIB_DIR="${INSTALL_PREFIX}/lib"
INCLUDE_DIR="${INSTALL_PREFIX}/include"

printf "\n"; info "Minot Uninstallation Script"; printf "\n"
printf "Will remove files from:\n  bin: ${BIN_DIR}\n  lib: ${LIB_DIR}\n  include: ${INCLUDE_DIR}\n\n"

TO_REMOVE_LIST=""
for f in \
  "${BIN_DIR}/minot" \
  "${BIN_DIR}/minot-coord" \
  "${BIN_DIR}"/wind-* \
  "${LIB_DIR}/librat.a" \
  "${LIB_DIR}/librat.so" \
  "${LIB_DIR}/librat.dylib" \
  "${LIB_DIR}/libratpub.a" \
  "${LIB_DIR}/libratpub.so" \
  "${LIB_DIR}/libratpub.dylib" \
    "${INCLUDE_DIR}/rat/rat.h"; do
    if [ -f "$f" ]; then
        TO_REMOVE_LIST="${TO_REMOVE_LIST}\n${f}"
    fi
done

SELF_PATH="${BIN_DIR}/minot-uninstall"

if [ -z "$TO_REMOVE_LIST" ]; then
    info "No Minot files found to remove."
    exit 0
fi

printf "The following files will be removed:\n"
printf "%b\n\n" "$TO_REMOVE_LIST"

# Skip prompt if -y/--yes was provided
if [ $SKIP_PROMPT -eq 0 ]; then
    prompt "Proceed? [y/N]"
    read ans || exit 1
    case "$ans" in y|Y|yes|YES) ;; *) info "Cancelled."; exit 0 ;; esac
fi

set +e
printf "%b" "$TO_REMOVE_LIST" | while IFS= read -r f; do
    [ -z "$f" ] && continue
    rm -f "$f" && success "Removed: $f" || warn "Could not remove: $f"
done

# Explicitly remove the uninstaller itself at the end
if [ -f "$SELF_PATH" ]; then
    rm -f "$SELF_PATH" && success "Removed: $SELF_PATH" || warn "Could not remove: $SELF_PATH"
fi
set -e

printf "\n"; success "All done!"; printf "\n"
EOF
    chmod +x "${UNINSTALL_PATH}"
    success "Script: minot-uninstall -> ${UNINSTALL_PATH}"
}

# Prefer the current stdin if it's a terminal,
# otherwise try /dev/tty. Returns non-zero when no interactive input
# source is available.
safe_read() {
    # usage: safe_read varname
    VAR_NAME="$1"
    if [ -t 0 ]; then
        read -r "$VAR_NAME" || return 1
    elif [ -r /dev/tty ]; then
        read -r "$VAR_NAME" < /dev/tty 2>/dev/null || return 1
    else
        return 1
    fi
    return 0
}

# Print usage information
usage() {
    cat <<EOF
${BOLD}Minot Installation Script${NC}

${BOLD}USAGE:${NC}
    install.sh [OPTIONS]

${BOLD}OPTIONS:${NC}
    -h, --help                Show this help message
    -v, --version VERSION     Install specific version (default: latest)
    -d, --dir DIR             Installation directory (default: ~/.local/bin)
    -e, --embed COMPONENTS    Embed components (comma-separated: coord, ros1, ros2, ros2-c, ratpub)
    -f, --features FEATURES   Advanced: Raw cargo features (comma-separated)
    -r, --ros-distro DISTRO   ROS2 C API binding to embed when building (jazzy, humble). Requires ROS2 sourced.
    -b, --build               Force build from source (skip binary download)
    -y, --yes                 Assume yes to all prompts
    -n, --no-default-embed    Do not enable the default 'coord' embed when building

${BOLD}EMBED COMPONENTS:${NC}
    coord         Embedded coordinator (default)
    ratpub        Ratpub publisher
    ros2-c        ROS2 publisher using the C bindings of rclc (needs sourced ROS)
    ros2-c-humble ROS2 publisher with specific handling of Humble using the C bindings of rclc (needs sourced ROS Humble)
    ros1-native   ROS1 publisher (native, no system dependencies)
    ros2-native   ROS2 publisher with RustDDS (native, no system dependencies)

${BOLD}EXAMPLES:${NC}
    ${CYAN}# Install latest version and use prebuilt binaries if available${NC}
    ./install.sh

    ${CYAN}# Install with ROS2 Jazzy support${NC}
    ./install.sh --ros-distro jazzy

    ${CYAN}# Build with multiple embedded components and force build from source${NC}
    ./install.sh --build --embed jazzy,ratpub

    ${CYAN}# Resolve to a semver compatible version${NC}
    ./install.sh --version 0.1

For more information, visit: ${BLUE}https://uos.github.io/minot/installation.html${NC}

EOF
}

get_latest_version() {
        info "Fetching latest release version..."
            if command -v curl >/dev/null 2>&1; then
                # Keep silent for API calls but show a one-line info before
                VERSION=$(curl -sSf "${GITHUB_API}/releases/latest" 2>/dev/null | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' || true)
            elif command -v wget >/dev/null 2>&1; then
                VERSION=$(wget -qO- "${GITHUB_API}/releases/latest" 2>/dev/null | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' || true)
            else
                warn "Neither curl nor wget found. Will fall back to building from source."
                return 1
            fi

        if [ -z "$VERSION" ]; then
            warn "Failed to fetch latest version from GitHub. Will fall back to building from source."
            return 1
        fi

        success "Latest version: ${CYAN}$VERSION${NC}"
        return 0
    }

detect_os() {
    local uname_s
    uname_s=$(uname -s 2>/dev/null || true)

    case "$uname_s" in
        Linux*)
            echo "linux"
            ;;
        Darwin*)
            echo "macos"
            ;;
        CYGWIN*|MINGW*|MSYS*)
            echo "windows"
            ;;
        *)
            error "Unsupported operating system: ${uname_s:-unknown}"
            ;;
    esac
}

detect_arch() {
    ARCH=$(uname -m)
    case "$ARCH" in
        x86_64|amd64)
            echo "x86_64"
            ;;
        aarch64|arm64)
            echo "aarch64"
            ;;
        armv7l|armhf)
            echo "armv7"
            ;;
        *)
            warn "Unknown architecture: $ARCH; cannot determine a prebuilt target triple"
            # Return empty to indicate we couldn't detect a known architecture.
            echo ""
            ;;
    esac
}

get_target_triple() {
    OS_NAME=$1
    ARCH_NAME=$2
    PREFER_GNU=$3
    
    case "$OS_NAME" in
        linux)
            case "$ARCH_NAME" in
                    x86_64)
                        # ROS builds use gnu, otherwise prefer musl for better portability
                        if [ "$PREFER_GNU" = "1" ]; then
                            echo "x86_64-unknown-linux-gnu"
                        else
                            echo "x86_64-unknown-linux-musl"
                        fi
                        ;;
                aarch64)
                    echo "aarch64-unknown-linux-gnu"
                    ;;
                armv7)
                    echo "armv7-unknown-linux-gnueabihf"
                    ;;
                *)
                    # Unknown architecture: cannot map to a prebuilt target triple.
                    # Return empty to indicate inability to determine a valid triple.
                    echo ""
                    return 1
                    ;;
            esac
            ;;
        macos)
            case "$ARCH_NAME" in
                x86_64)
                    echo "x86_64-apple-darwin"
                    ;;
                aarch64)
                    echo "aarch64-apple-darwin"
                    ;;
            esac
            ;;
    esac
}


detect_ros_from_env_and_prompt() {
    if [ -n "$ROS_DISTRO" ]; then
        return 0
    fi

    local detected=""
    if [ -n "${ROS_DISTRO}" ]; then
        detected="${ROS_DISTRO}"
    fi

    if [ -z "$detected" ] && [ -n "${ROS_DISTRO}" ]; then
        detected="${ROS_DISTRO}"
    fi

    if [ -z "$detected" ] && echo ":${PATH}:" | grep -q '/opt/ros/'; then
        # extract distro name from first /opt/ros/<distro>/bin occurrence
        detected=$(echo ":${PATH}:" | sed -n 's/.*:\/opt\/ros\/\([^:]*\)\/bin:.*/\1/p' | sed -n '1p' || true)
    fi

    if [ -z "$detected" ]; then
        return 0
    fi

    detected=$(echo "$detected" | tr '[:upper:]' '[:lower:]')

    case "$detected" in
        jazzy|humble|galactic|foxy|iron|rolling)
            ;; # supported
        *)
            warn "Detected ROS distro '$detected' is not in supported list; falling back to 'jazzy'."
            detected="jazzy"
            ;;
    esac

    if [ $YES_TO_ALL -eq 1 ]; then
        ROS_DISTRO="$detected"
        info "Auto-enabled ROS distro: ${CYAN}$ROS_DISTRO${NC} (from environment)"
        return 0
    fi

    printf "\n"
    prompt "Detected ROS distro in your environment: '${detected}'. Install with this distro? [Y/n]"
    if safe_read resp; then
        case "$resp" in
            [nN][oO]|[nN])
                info "Not enabling ROS embed by default."
                ;;
            *)
                ROS_DISTRO="$detected"
                info "Enabled ROS distro: ${CYAN}$ROS_DISTRO${NC}"
                ;;
        esac
    else
        warn "Could not read response; not enabling ROS embed by default."
    fi
}

parse_semver() {
    local s="$1"
    s=${s#v}
    if echo "$s" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
        local sem=$(echo "$s" | grep -Eo '^[0-9]+\.[0-9]+\.[0-9]+(-[^+]+)?')
        local major=$(echo "$sem" | cut -d. -f1)
        local minor=$(echo "$sem" | cut -d. -f2)
        local patch_with=$(echo "$sem" | cut -d. -f3)
        local patch=$(echo "$patch_with" | sed -E 's/[^0-9].*$//')
        local prerelease=""
        if echo "$sem" | grep -q '-'; then
            prerelease=$(echo "$sem" | sed -E 's/^[0-9]+\.[0-9]+\.[0-9]+-//')
        fi
        echo "$major $minor $patch $prerelease $sem"
        return 0
    fi
    return 1
}

compare_semver_parts() {
    local a_major=$1 a_minor=$2 a_patch=$3
    local b_major=$4 b_minor=$5 b_patch=$6
    if [ "$a_major" -gt "$b_major" ]; then return 1; fi
    if [ "$a_major" -lt "$b_major" ]; then return 2; fi
    if [ "$a_minor" -gt "$b_minor" ]; then return 1; fi
    if [ "$a_minor" -lt "$b_minor" ]; then return 2; fi
    if [ "$a_patch" -gt "$b_patch" ]; then return 1; fi
    if [ "$a_patch" -lt "$b_patch" ]; then return 2; fi
    return 0
}

compat_upper_bound() {
    local major=$1 minor=$2 patch=$3
    if [ "$major" -eq 0 ]; then
        echo "$major $((minor + 1)) 0"
    else
        echo "$((major + 1)) 0 0"
    fi
}

is_in_range() {
    local c1=$1 c2=$2 c3=$3
    local r1=$4 r2=$5 r3=$6
    local u1=$7 u2=$8 u3=$9

    compare_semver_parts "$c1" "$c2" "$c3" "$r1" "$r2" "$r3"
    local cmp_to_req=$?
    if [ $cmp_to_req -eq 2 ]; then
        return 1
    fi

    compare_semver_parts "$c1" "$c2" "$c3" "$u1" "$u2" "$u3"
    local cmp_to_upper=$?
    if [ $cmp_to_upper -ne 2 ]; then
        # cmp_to_upper == 0 means equal -> >= upper, cmp_to_upper ==1 means > upper
        return 1
    fi

    return 0
}
 

resolve_requested_version() {
    # If $VERSION is a prefix like '0.1', resolve it to the newest release
    # tag from GitHub that matches that major/minor. If VERSION is empty or
    # already a full tag/semver, leave it as-is.
    if [ -z "$VERSION" ]; then
        return 0
    fi

    # If user provided X.Y (prefix)
    if echo "$VERSION" | grep -Eq '^[0-9]+\.[0-9]+$'; then
        local orig="$VERSION"
        local want_major=$(echo "$VERSION" | cut -d. -f1)
        local want_minor=$(echo "$VERSION" | cut -d. -f2)
        local per_page=100
        local page=1
        local found_prerelease=""

        while :; do
            local releases_json=""
            if command -v curl >/dev/null 2>&1; then
                releases_json=$(curl -sSf "${GITHUB_API}/releases?per_page=${per_page}&page=${page}" 2>/dev/null || true)
            elif command -v wget >/dev/null 2>&1; then
                releases_json=$(wget -qO- "${GITHUB_API}/releases?per_page=${per_page}&page=${page}" 2>/dev/null || true)
            else
                warn "Neither curl nor wget found; cannot resolve version prefix '$VERSION'."
                return 1
            fi

            # If no JSON returned or empty page, stop
            if [ -z "$releases_json" ]; then
                break
            fi

            local any_tag=0
            for tag in $(printf "%s" "$releases_json" | grep '"tag_name"' | sed -E 's/.*"([^\"]+)".*/\1/' ); do
                any_tag=1
                t=${tag#v}
                parsed=$(parse_semver "$t" 2>/dev/null || true)
                if [ -z "$parsed" ]; then
                    continue
                fi
                IFS=' ' read c_major c_minor c_patch c_prerelease c_sem <<EOF
$parsed
EOF
                if [ "$c_major" -eq "$want_major" ] && [ "$c_minor" -eq "$want_minor" ]; then
                    if [ -z "$c_prerelease" ]; then
                        VERSION="$tag"
                        success "Resolved requested prefix '${CYAN}$orig${NC}' to ${CYAN}$VERSION${NC}"
                        return 0
                    else
                        # remember the first prerelease candidate in case no stable exists
                        if [ -z "$found_prerelease" ]; then
                            found_prerelease="$tag"
                        fi
                    fi
                fi
            done

            # If no tags on this page, stop paging
            if [ $any_tag -eq 0 ]; then
                break
            fi

            page=$((page + 1))
        done

        # If we didn't find a stable release but found a prerelease candidate, use it
        if [ -n "$found_prerelease" ]; then
            VERSION="$found_prerelease"
            success "Resolved requested prefix '${CYAN}$orig${NC}' to prerelease ${CYAN}$VERSION${NC}"
            return 0
        fi

        warn "No release found matching prefix '$orig'"
        return 1
    fi

    return 0
}

embed_to_features() {
    local input="$1"
    local IFS=','
    local out=""
    for comp in $input; do
        comp=$(printf "%s" "$comp" | sed -E 's/^\s+|\s+$//g')
        case "$comp" in
            coord) feat="embed-coord" ;;
            ratpub) feat="embed-ratpub" ;;
            ros1-native) feat="embed-ros1-native" ;;
            ros2-native) feat="embed-ros2-native" ;;
            "ros2-c-humble"|"ros2_c_humble"|"ros2c-humble"|"ros2c_humble") feat="embed-ros2-c-humble" ;;
            "ros2-c"|"ros2_c"|"ros2c") feat="embed-ros2-c" ;;
            "") continue ;;
            *)
                warn "Unknown embed component: $comp; skipping"
                continue
                ;;
        esac

        if [ -n "$out" ]; then
            out="$out,$feat"
        else
            out="$feat"
        fi
    done

    printf "%s" "$out"
}


check_binary_exists() {
    TARGET=$1
    ARCHIVE_NAME=$2
    VERSION=$3
    
    URL="${GITHUB_RELEASE}/${VERSION}/${ARCHIVE_NAME}.tar.gz"
    
    if command -v curl >/dev/null 2>&1; then
        if curl -sSfI "$URL" >/dev/null 2>&1; then
            return 0
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -q --spider "$URL" 2>/dev/null; then
            return 0
        fi
    fi
    
    return 1
}

get_release_manifest() {
    VERSION=$1
    MANIFEST_URL="${GITHUB_RELEASE}/${VERSION}/manifest.json"
    
    if command -v curl >/dev/null 2>&1; then
        curl -sSfL "$MANIFEST_URL" 2>/dev/null || echo ""
    elif command -v wget >/dev/null 2>&1; then
        wget -qO- "$MANIFEST_URL" 2>/dev/null || echo ""
    else
        echo ""
    fi
}

get_manifest_subdirs() {
    MANIFEST_JSON="$1"
    ARCHIVE_NAME="$2"    
    echo "$MANIFEST_JSON" | sed -n "/\"${ARCHIVE_NAME}\"/,/}/p" | grep '"subdirs"' | sed -E 's/.*"subdirs":\s*\[([^\]]*)\].*/\1/' | tr -d '"' | tr ',' '\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed '/^$/d'
}

is_feature_subset() {
    REQUESTED="$1"
    AVAILABLE="$2"
    
    if [ -z "$REQUESTED" ]; then
        return 0
    fi
    
    echo "$REQUESTED" | tr ',' '\n' | while IFS= read -r req; do
        req=$(echo "$req" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        [ -z "$req" ] && continue
        
        if ! echo "$AVAILABLE" | grep -qx "$req"; then
            exit 1
        fi
    done
    
    return $?
}

select_best_archive() {
    MANIFEST_JSON="$1"
    TARGET="$2"
    REQUESTED_FEATURES="$3"
    ROS_DISTRO_REQ="$4"

    BEST_ARCH=""
    BEST_EXTRA_COUNT=999999

    # info "DEBUG: Looking for target '$TARGET' with features '$REQUESTED_FEATURES' and distro '$ROS_DISTRO_REQ'"

    for arch in $(get_manifest_archives_for_target "$MANIFEST_JSON" "$TARGET"); do
        # info "DEBUG: Checking archive candidate: $arch"
        
        AVAIL_FEATS=$(get_manifest_features "$MANIFEST_JSON" "$arch")
        # info "DEBUG:   Available features: $(echo "$AVAIL_FEATS" | tr '\n' ',')"

        # feature subset check
        if ! is_feature_subset "$REQUESTED_FEATURES" "$AVAIL_FEATS"; then
            # info "DEBUG:   -> Rejected: Missing required features"
            continue
        fi

        # ros distro match
        ARCH_DISTRO=$(get_manifest_ros_distro "$MANIFEST_JSON" "$arch")
        # info "DEBUG:   Archive Distro: '$ARCH_DISTRO'"

        if [ -n "$ROS_DISTRO_REQ" ]; then
            if [ -z "$ARCH_DISTRO" ]; then
                 # info "DEBUG:   -> Rejected: Requesting ROS '$ROS_DISTRO_REQ' but archive has none"
                 continue
            fi
            
            # Case-insensitive comparison
            REQ_LOWER=$(echo "$ROS_DISTRO_REQ" | tr '[:upper:]' '[:lower:]')
            ARCH_LOWER=$(echo "$ARCH_DISTRO" | tr '[:upper:]' '[:lower:]')
            
            if [ "$REQ_LOWER" != "$ARCH_LOWER" ]; then
                # info "DEBUG:   -> Rejected: Distro mismatch ($REQ_LOWER vs $ARCH_LOWER)"
                continue
            fi
        fi
        
        # Calculate "Exactness" score
        AVAIL_COUNT=$(printf "%s\n" "$AVAIL_FEATS" | sed '/^$/d' | wc -l | tr -d ' ')
        REQ_COUNT=$(printf "%s" "$REQUESTED_FEATURES" | tr ',' '\n' | sed '/^$/d' | wc -l | tr -d ' ')
        EXTRA_COUNT=$((AVAIL_COUNT - REQ_COUNT))

        # info "DEBUG:   -> Candidate Valid. Extra features: $EXTRA_COUNT"

        # prefer archives without ros_distro when not requested
        if [ -z "$ROS_DISTRO_REQ" ] && [ -n "$ARCH_DISTRO" ]; then
            EXTRA_COUNT=$((EXTRA_COUNT + 1000))
        fi
        
        if [ "$EXTRA_COUNT" -lt "$BEST_EXTRA_COUNT" ]; then
            BEST_EXTRA_COUNT="$EXTRA_COUNT"
            BEST_ARCH="$arch"
        fi
    done

    if [ -n "$BEST_ARCH" ]; then
        printf "%s" "$BEST_ARCH"
        return 0
    fi
    return 1
}

check_ros_distro_available() {
    DISTRO="$1"
    
    if [ -n "${ROS_DISTRO}" ] && [ "${ROS_DISTRO}" = "$DISTRO" ]; then
        return 0
    fi
    
    if [ -f "/opt/ros/${DISTRO}/setup.bash" ]; then
        return 0
    fi
    
    return 1
}

check_feature_compatibility() {
    REQUESTED_FEATURES="$1"  # comma-separated
    AVAILABLE_FEATURES="$2"  # newline-separated from get_manifest_features
    
    if [ -z "$REQUESTED_FEATURES" ]; then
        return 0
    fi
    
    echo "$REQUESTED_FEATURES" | tr ',' '\n' | while IFS= read -r req_feat; do
        req_feat=$(echo "$req_feat" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        [ -z "$req_feat" ] && continue
        
        # Check if this feature is in available features
        if ! echo "$AVAILABLE_FEATURES" | grep -qx "$req_feat"; then
            # Feature not found
            return 1
        fi
    done
    
    # All features found
    return 0
}

download_and_extract() {
    URL="$1"
    DEST_DIR="$2"
    ARCHIVE_FILE="$3"

    info "Downloading $ARCHIVE_FILE..."
    
    if command -v curl >/dev/null 2>&1; then
        if ! curl --progress-bar -fL "$URL" -o "$ARCHIVE_FILE"; then
            return 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        if ! wget --progress=bar:force "$URL" -O "$ARCHIVE_FILE"; then
            return 1
        fi
    else
        warn "Neither curl nor wget found."
        return 1
    fi

    EXTRACT_TMP=$(mktemp -d)
    tar xzf "$ARCHIVE_FILE" -C "$EXTRACT_TMP"
    
    CREATED_DIR=$(find "$EXTRACT_TMP" -mindepth 1 -maxdepth 1 -type d | head -n 1)
    
    if [ -n "$CREATED_DIR" ]; then
        cp -R "$CREATED_DIR"/* "$DEST_DIR/"
    else
        cp -R "$EXTRACT_TMP"/* "$DEST_DIR/"
    fi
    
    rm -rf "$EXTRACT_TMP"
    return 0
}

download_and_install() {
    TARGET=$1
    PRIMARY_ARCH_NAME=$2
    BASE_ARCH_NAME=$3
    VERSION=$4
    REQUESTED_FEATURES="$5"

    TMP_DIR=$(mktemp -d)
    trap "rm -rf '$TMP_DIR'" EXIT
    
    STAGE_DIR="$TMP_DIR/stage"
    mkdir -p "$STAGE_DIR"

    cd "$TMP_DIR" || return 1

    # Download and Extract BASE Archive first (if it exists)
    # This ensures libraries and standard tools are present
    if [ -n "$BASE_ARCH_NAME" ] && [ "$BASE_ARCH_NAME" != "$PRIMARY_ARCH_NAME" ]; then
        BASE_URL="${GITHUB_RELEASE}/${VERSION}/${BASE_ARCH_NAME}.tar.gz"
        info "Fetching base artifacts from ${BASE_ARCH_NAME}..."
        if ! download_and_extract "$BASE_URL" "$STAGE_DIR" "${BASE_ARCH_NAME}.tar.gz"; then
            warn "Failed to download base archive. Setup might be incomplete."
            return 1
        fi
    fi

    # Download and Extract PRIMARY Archive (Overlay)
    PRIMARY_URL="${GITHUB_RELEASE}/${VERSION}/${PRIMARY_ARCH_NAME}.tar.gz"
    if [ -n "$BASE_ARCH_NAME" ]; then
        info "Fetching overlay artifacts from ${PRIMARY_ARCH_NAME}..."
    else
        info "Fetching artifacts..."
    fi

    if ! download_and_extract "$PRIMARY_URL" "$STAGE_DIR" "${PRIMARY_ARCH_NAME}.tar.gz"; then
        warn "Failed to download primary archive."
        return 1
    fi
    
    mkdir -p "$INSTALL_DIR"
    INSTALL_PREFIX=$(dirname "$INSTALL_DIR")
    INSTALL_LIB_DIR="${INSTALL_PREFIX}/lib"
    INSTALL_INCLUDE_DIR="${INSTALL_PREFIX}/include"
    mkdir -p "$INSTALL_LIB_DIR" "$INSTALL_INCLUDE_DIR"

    info "Installing..."
    printf "\n"

    should_install_binary() {
        binname="$1"
        req="$2"
        case "$binname" in
            minot|minot-coord) return 0 ;;
            wind-ratpub*) echo "$req" | grep -Eq '(\bembed-ratpub\b|\bembed-ros\b)' && return 0 || return 1 ;;
            wind-ros1*)   echo "$req" | grep -Eq '(\bembed-ros1-native\b|\bembed-ros\b|\bembed-ros-native\b)' && return 0 || return 1 ;;
            wind-ros2-native*) echo "$req" | grep -Eq '(\bembed-ros2-native\b|\bembed-ros-native\b)' && return 0 || return 1 ;;
            wind-ros2-c*) echo "$req" | grep -Eq '(\bembed-ros2-c\b|\bembed-ros2-c-[a-z]+\b|\bembed-ros\b)' && return 0 || return 1 ;;
            *) [ -z "$req" ] && return 0 || return 1 ;;
        esac
    }

    choose_minot_path() {
        root="$1"
        req="$2"
        best_path=""
        
        case ",$req," in
            *,embed-ros2-c,*|*,embed-ros2-c-humble,*|*,embed-ros2-c-jazzy,*|*,embed-ros,*)
                if echo ",$req," | grep -q ",embed-ros1-native,"; then
                    [ -x "$root/ros2_1/minot" ] && best_path="$root/ros2_1/minot"
                fi
                [ -z "$best_path" ] && [ -x "$root/ros2/minot" ] && best_path="$root/ros2/minot"
                ;;
        esac
        
        if [ -z "$best_path" ]; then
            case ",$req," in
                *,embed-ratpub,*) [ -x "$root/rat/minot" ] && best_path="$root/rat/minot" ;;
                *,embed-coord,*)  [ -x "$root/co/minot" ] && best_path="$root/co/minot" ;;
            esac
        fi
        
        if [ -z "$best_path" ] && [ -x "$root/min/minot" ]; then
            best_path="$root/min/minot"
        fi
        
        printf "%s" "$best_path"
    }

    CHOSEN_MINOT=$(choose_minot_path "$STAGE_DIR" "$REQUESTED_FEATURES")

    INSTALLED_ANY=0
    
    if [ -n "$CHOSEN_MINOT" ] && [ -x "$CHOSEN_MINOT" ]; then
        VARIANT_NAME=$(basename "$(dirname "$CHOSEN_MINOT")")
        
    cp "$CHOSEN_MINOT" "$INSTALL_DIR/minot"
    chmod +x "$INSTALL_DIR/minot"
    success "Binary: minot -> $INSTALL_DIR/minot"
        INSTALLED_ANY=1
    else
        warn "No suitable 'minot' binary found in the downloaded artifacts."
    fi

    for binary in "$STAGE_DIR"/*; do
        if [ -f "$binary" ] && [ -x "$binary" ]; then
            BINARY_NAME=$(basename "$binary")
            case "$BINARY_NAME" in
                minot) continue ;; # Skip loose minot if any
                *.a|*.so|*.dylib|*.dll|*.h|*.d|*.sha256) continue ;;
            esac
            
            if [ "$BINARY_NAME" = "minot-coord" ] || should_install_binary "$BINARY_NAME" "$REQUESTED_FEATURES"; then
                cp "$binary" "$INSTALL_DIR/$BINARY_NAME"
                chmod +x "$INSTALL_DIR/$BINARY_NAME"
                success "Binary: $BINARY_NAME -> $INSTALL_DIR/$BINARY_NAME"
                INSTALLED_ANY=1
            fi
        fi
    done

    for lib_file in "$STAGE_DIR"/*.a "$STAGE_DIR"/*.so "$STAGE_DIR"/*.dylib; do
        if [ -f "$lib_file" ]; then
            FILENAME=$(basename "$lib_file")
            cp "$lib_file" "$INSTALL_LIB_DIR/$FILENAME"
            success "Library: $FILENAME -> $INSTALL_LIB_DIR/$FILENAME"
            INSTALLED_ANY=1
        fi
    done

    HEADER_SUBDIR="$INSTALL_INCLUDE_DIR/rat"
    mkdir -p "$HEADER_SUBDIR"
    for header_file in "$STAGE_DIR"/*.h; do
        if [ -f "$header_file" ]; then
            FILENAME=$(basename "$header_file")
            cp "$header_file" "$HEADER_SUBDIR/$FILENAME"
            success "Header: $FILENAME -> $HEADER_SUBDIR/$FILENAME"
            INSTALLED_ANY=1
        fi
    done

    write_uninstaller "$INSTALL_DIR"

    if [ $INSTALLED_ANY -eq 0 ]; then
        warn "Artifacts were empty or incompatible; falling back to build."
        return 1
    fi

    cd - >/dev/null || true
    return 0
}

check_rust() {
    if ! command -v cargo >/dev/null 2>&1; then
        warn "Rust is not installed on your system."
        printf "\n${BOLD}To build Minot from source, you need to install Rust.${NC}\n"
        printf "Visit: ${BLUE}https://rustup.rs/${NC}\n\n"
        printf "Quick install command:\n"
        printf "  ${GREEN}curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh${NC}\n\n"
        
        if [ $YES_TO_ALL -eq 0 ]; then
            prompt "Would you like to install Rust now? [Y/n]"
            if ! safe_read response; then
                error "Could not read input from terminal. Re-run interactively or use --yes to accept defaults."
            fi
            case "$response" in
                [nN][oO]|[nN])
                    exit 1
                    ;;
                *)
                    info "Installing Rust..."
                    if command -v curl >/dev/null 2>&1; then
                        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y || error "Failed to install Rust"
                        . "$HOME/.cargo/env"
                        success "Rust installed successfully!"
                    else
                        error "curl is required to install Rust. Please install curl or Rust manually."
                    fi
                    ;;
            esac
        else
            error "Rust is required to build from source. Install it from https://rustup.rs/"
        fi
    fi
    return 0
}

build_from_source() {
    if ! check_rust; then
        error "Rust is required to build from source"
    fi

    if [ -n "$EMBED_COMPONENTS" ]; then
        EMBED_FEATURES=$(embed_to_features "$EMBED_COMPONENTS")
        if [ -n "$FEATURES" ]; then
            FEATURES="${FEATURES},${EMBED_FEATURES}"
        else
            FEATURES="$EMBED_FEATURES"
        fi
    fi

    BUILD_FEATURES="$FEATURES"
    
    if [ "$NO_DEFAULT_EMBED" -eq 0 ]; then
        case ",$BUILD_FEATURES," in
            *,embed-coord,*)
                # already present, do nothing
                ;;
            *)
                # Add embed-coord to the features
                if [ -n "$BUILD_FEATURES" ]; then
                    BUILD_FEATURES="embed-coord,${BUILD_FEATURES}"
                else
                    BUILD_FEATURES="embed-coord"
                fi
                ;;
        esac
    fi

    if [ -n "$ROS_DISTRO" ]; then
        ROS_DISTRO_LC=$(echo "$ROS_DISTRO" | tr '[:upper:]' '[:lower:]')
        if [ "$ROS_DISTRO_LC" = "jazzy" ]; then
            ROS2_C_FEATURE="embed-ros2-c"
        else
            ROS2_C_FEATURE="embed-ros2-c-${ROS_DISTRO_LC}"
        fi
        case ",$BUILD_FEATURES," in
            *,${ROS2_C_FEATURE},*|*,embed-ros,*|*,embed-ros2-c,*)
                # already present, a combined 'embed-ros' feature exists, or generic embed-ros2-c present; do nothing
                ;;
            *)
                if [ -n "$BUILD_FEATURES" ]; then
                    BUILD_FEATURES="${BUILD_FEATURES},${ROS2_C_FEATURE}"
                else
                    BUILD_FEATURES="${ROS2_C_FEATURE}"
                fi
                ;;
        esac
    fi

    info "Building with features: ${CYAN}$BUILD_FEATURES${NC}"

    # Check if building with ros2-c. It requires libclang-dev on Ubuntu.
    case ",$BUILD_FEATURES," in
        *,embed-ros2-c,*|*,embed-ros2-c-*,*|*,embed-ros,*)
            if [ -f /etc/os-release ]; then
                OS_ID=$(sed -n 's/^ID=\(.*\)$/\1/p' /etc/os-release | tr -d '"') || OS_ID=""
                case "$OS_ID" in
                    ubuntu|debian)
                        # Check if libclang-dev is installed
                        if ! dpkg -l libclang-dev >/dev/null 2>&1; then
                            printf "\n${RED}${BOLD}Missing dependency:${NC} ${BOLD}libclang-dev${NC}\n"
                            printf "\n${YELLOW}Building with ROS2-C support requires libclang-dev.${NC}\n"
                            printf "Please install it by running:\n\n"
                            printf "  ${GREEN}sudo apt install libclang-dev${NC}\n\n"
                            printf "Then re-run this installation script.\n\n"
                            exit 1
                        fi
                        ;;
                esac
            fi
            ;;
    esac

    USE_BASH_SOURCE=0
    ROS_SETUP=""
    if [ -n "$ROS_DISTRO" ]; then
        # Check for any /opt/ros/*/bin entry in PATH (this indicates ROS was sourced)
        if echo ":${PATH}:" | grep -Eq '/opt/ros/[^:]+/bin'; then
            info "ROS support activated."
        elif command -v ros2 >/dev/null 2>&1; then
            info "ROS support activated."
        else
            FOUND_SETUP=""
            for p in /opt/ros/*/setup.bash /opt/ros/*/setup.sh /opt/ros/*/setup.zsh; do
                if [ -f "$p" ]; then
                    FOUND_SETUP="$p"
                    break
                fi
            done

            if [ -n "$FOUND_SETUP" ]; then
                ROS_SETUP="$FOUND_SETUP"
                if [ $YES_TO_ALL -eq 1 ]; then
                    info "Auto-sourcing ${ROS_SETUP} for the build (--yes)."
                    USE_BASH_SOURCE=1
                else
                    printf "\n"
                    prompt "ROS does not appear to be sourced. Source ${ROS_SETUP} now for the build? [Y/n]"
                    if ! safe_read resp; then
                        error "Could not read input from terminal. Re-run interactively or set --yes to auto-enable ROS embed."
                    fi
                    case "$resp" in
                        [nN][oO]|[nN])
                            error "Please source ROS in your shell (or open a terminal with ROS sourced) and re-run this script."
                            ;;
                        *)
                            USE_BASH_SOURCE=1
                            ;;
                    esac
                fi
            else
                error "ROS does not appear to be sourced and no setup script was found under /opt/ros. Please source ROS in your shell or install ROS."
            fi
        fi
    fi

    mkdir -p "$INSTALL_DIR"

    TMP_BUILD_DIR=$(mktemp -d)
    trap "rm -rf '$TMP_BUILD_DIR'" EXIT

    info "Cloning repository..."

    if [ -n "$VERSION" ]; then
        RAW_VERSION="$VERSION"
        TAG_TO_USE=$(printf "%s" "$RAW_VERSION" | grep -Eo 'v?[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n1)

        if [ -z "$TAG_TO_USE" ]; then
            TAG_TO_USE=$(printf "%s" "$RAW_VERSION" | awk '{print $1}')
        fi

        case "$TAG_TO_USE" in
            v*) ;;
            *) TAG_TO_USE="v$TAG_TO_USE" ;;
        esac

        if git clone --depth 1 --branch "$TAG_TO_USE" --single-branch "https://github.com/${REPO}.git" "$TMP_BUILD_DIR" 2>/dev/null; then
            : # success
        else
            warn "Could not clone branch/tag '$TAG_TO_USE' directly; attempting clone+checkout..."
            if ! git clone --depth 1 "https://github.com/${REPO}.git" "$TMP_BUILD_DIR"; then
                error "Failed to clone repository"
            fi
            (cd "$TMP_BUILD_DIR" && 
                if git rev-parse --verify "refs/tags/$TAG_TO_USE" >/dev/null 2>&1; then
                    git checkout "refs/tags/$TAG_TO_USE" || exit 1
                else
                    git fetch --tags origin || exit 1
                    git checkout "refs/tags/$TAG_TO_USE" || exit 1
                fi
            ) || error "Failed to checkout tag: $TAG_TO_USE"
        fi
    else
        if ! git clone --depth 1 "https://github.com/${REPO}.git" "$TMP_BUILD_DIR"; then
            error "Failed to clone repository"
        fi
    fi

    cd "$TMP_BUILD_DIR" || error "Failed to enter build directory"

    BUILD_CMD="cargo build --release --locked"
    if [ "$NO_DEFAULT_EMBED" -eq 1 ]; then
        BUILD_CMD="$BUILD_CMD --no-default-features"
    fi
    if [ -n "$BUILD_FEATURES" ]; then
        BUILD_CMD="$BUILD_CMD --features $BUILD_FEATURES"
    fi

    printf "\n${BOLD}Build command:${NC} ${CYAN}%s${NC}\n\n" "$BUILD_CMD"

    info "Building binaries and libraries..."
    if [ "$USE_BASH_SOURCE" -eq 1 ]; then
        if [ -n "$ROS_SETUP" ]; then
            if command -v bash >/dev/null 2>&1; then
                info "Running build in a bash subshell with ROS sourced: ${ROS_SETUP}"
                bash -lc ". \"${ROS_SETUP}\" && cd \"$TMP_BUILD_DIR\" && ${BUILD_CMD}" || error "Build failed"
            else
                warn "bash not found; attempting to source using sh. This may fail for some ROS setups."
                . "${ROS_SETUP}" && eval "$BUILD_CMD" || error "Build failed"
            fi
        else
            error "Internal error: requested to source ROS but no setup script found."
        fi
    else
        eval "$BUILD_CMD" || error "Build failed"
    fi

    INSTALL_PREFIX=$(dirname "$INSTALL_DIR")
    INSTALL_LIB_DIR="${INSTALL_PREFIX}/lib"
    INSTALL_INCLUDE_DIR="${INSTALL_PREFIX}/include"
    mkdir -p "$INSTALL_LIB_DIR" "$INSTALL_INCLUDE_DIR"

    printf "\n"
    info "Installing..."
    printf "\n"

    ART_DIR="target/release"
    for binary in "$ART_DIR"/minot "$ART_DIR"/minot-coord "$ART_DIR"/wind-*; do
        if [ -f "$binary" ]; then
            BINARY_NAME=$(basename "$binary")
            # Skip .d files (dependency files from Rust build)
            case "$BINARY_NAME" in
                *.d)
                    continue
                    ;;
            esac
            cp "$binary" "$INSTALL_DIR/$BINARY_NAME"
            chmod +x "$INSTALL_DIR/$BINARY_NAME"
            success "Installed: $BINARY_NAME -> $INSTALL_DIR/$BINARY_NAME"
        fi
    done

    # Install libraries if present
    for lib_file in "$ART_DIR"/lib*.a "$ART_DIR"/lib*.so "$ART_DIR"/lib*.dylib; do
        if [ -f "$lib_file" ]; then
            FILENAME=$(basename "$lib_file")
            cp "$lib_file" "$INSTALL_LIB_DIR/$FILENAME"
            success "Installed library: $FILENAME -> $INSTALL_LIB_DIR"
        fi
    done

    HEADER_SUBDIR="$INSTALL_INCLUDE_DIR/rat"
    mkdir -p "$HEADER_SUBDIR"
    if [ -f "rat/rat.h" ]; then
        cp "rat/rat.h" "$HEADER_SUBDIR/rat.h"
        success "Installed header: rat.h -> $HEADER_SUBDIR"
    fi

    # Generate and install uninstaller script using detected paths
    write_uninstaller "$INSTALL_DIR"

    cd - >/dev/null || true
}

check_path() {
    case ":${PATH}:" in
        *":${INSTALL_DIR}:"*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

suggest_path_update() {
    if ! check_path; then
        warn "Installation directory is not in your PATH: $INSTALL_DIR"
        printf "\nTo use Minot, add the following to your shell configuration file:\n"
        
        # Detect shell
        SHELL_NAME=$(basename "$SHELL")
        case "$SHELL_NAME" in
            bash)
                CONFIG_FILE="~/.bashrc"
                ;;
            zsh)
                CONFIG_FILE="~/.zshrc"
                ;;
            fish)
                CONFIG_FILE="~/.config/fish/config.fish"
                printf "  ${GREEN}set -gx PATH \$PATH ${INSTALL_DIR}${NC}\n\n"
                return
                ;;
            *)
                CONFIG_FILE="~/.profile"
                ;;
        esac
        
        printf "  ${GREEN}export PATH=\"\$PATH:${INSTALL_DIR}\"${NC}\n"
        printf "\nAdd this to: ${BLUE}${CONFIG_FILE}${NC}\n\n"
    fi
}

is_minot_installed() {
    if command -v minot >/dev/null 2>&1; then
        MINOT_PATH=$(command -v minot)
        # Try to read a version string; if it prints something non-empty, accept it.
        MINOT_VER=$("$MINOT_PATH" --version 2>/dev/null || true)
        if [ -n "$MINOT_VER" ]; then
            return 0
        else
            # Found an executable named 'minot' but it didn't identify itself
            warn "Found 'minot' at ${MINOT_PATH} but it did not return a version; ignoring this entry."
        fi
    fi

    # Also consider installed if binaries exist in the chosen install directory
    if [ -x "${INSTALL_DIR}/minot" ] || [ -x "${INSTALL_DIR}/minot-coord" ]; then
        return 0
    fi

    return 1
}

prompt_uninstall_existing() {
    if ! is_minot_installed; then
        return 0
    fi

    INSTALLED_VER=""
    if command -v minot >/dev/null 2>&1; then
        INSTALLED_VER=$(minot --version 2>/dev/null || true)
    fi

    if [ -n "$INSTALLED_VER" ]; then
        info "Detected existing Minot: ${CYAN}${INSTALLED_VER}${NC}"
    else
        info "Detected existing Minot installation"
    fi

    if [ $YES_TO_ALL -eq 1 ]; then
        info "Auto-uninstall enabled (-y): attempting to uninstall existing Minot..."
        if command -v minot-uninstall >/dev/null 2>&1; then
            # Use the uninstaller non-interactively with -y flag
            if minot-uninstall -y; then
                success "Previous Minot uninstalled"
                return 0
            fi
            error "Failed to run 'minot-uninstall'. Please uninstall the existing Minot manually and re-run this script."
        else
            # No 'minot-uninstall' command available; try removing binaries from INSTALL_DIR
            if [ -f "${INSTALL_DIR}/minot" ] || [ -f "${INSTALL_DIR}/minot-coord" ]; then
                rm -f "${INSTALL_DIR}/minot" "${INSTALL_DIR}/minot-coord" "${INSTALL_DIR}/minot-uninstall" || error "Failed to remove existing binaries from ${INSTALL_DIR}. Please remove them manually."
                success "Removed existing binaries from ${INSTALL_DIR}"
                return 0
            fi
            error "Cannot run 'minot-uninstall' and no binaries found in ${INSTALL_DIR}; please uninstall manually."
        fi
    fi

    printf "\n"
    if command -v minot-uninstall >/dev/null 2>&1; then
        if [ $YES_TO_ALL -eq 1 ]; then
            info "Auto-uninstall enabled (-y): running 'minot-uninstall'..."
            if minot-uninstall -y; then
                success "Previous Minot uninstalled"
                return 0
            fi
            error "Failed to run 'minot-uninstall'. Please uninstall manually and re-run this script."
        fi

        # Ask the user before running the external uninstaller
        prompt "Previous Minot installation detected. Run 'minot-uninstall' to uninstall it now? [Y/n]"
        if safe_read resp; then
            case "$resp" in
                [nN][oO]|[nN])
                    error "Please uninstall the existing Minot before proceeding, or re-run with --yes to auto-uninstall."
                    ;;
                *)
                    info "Running 'minot-uninstall'..."
                    # Run the uninstaller in non-interactive mode to ensure a clean removal
                    if minot-uninstall -y; then
                        success "Previous Minot uninstalled"
                        return 0
                    fi
                    error "Failed to run 'minot-uninstall'. Please uninstall manually and re-run this script."
                    ;;
            esac
        else
            error "Could not read input from terminal. Re-run interactively or use --yes to auto-uninstall."
        fi
    fi
    
    prompt "A previous Minot installation was detected. Would you like me to uninstall it now? [Y/n]"
    if ! safe_read resp; then
        error "Could not read input from terminal. Re-run interactively or use --yes to auto-uninstall."
    fi
    case "$resp" in
        [nN][oO]|[nN])
            error "Please uninstall the existing Minot before proceeding, or re-run with --yes to auto-uninstall."
            ;;
        *)
            info "Attempting to uninstall existing Minot..."
            if [ -f "${INSTALL_DIR}/minot" ] || [ -f "${INSTALL_DIR}/minot-coord" ]; then
                rm -f "${INSTALL_DIR}/minot" "${INSTALL_DIR}/minot-coord" "${INSTALL_DIR}/minot-uninstall" || error "Failed to remove existing binaries from ${INSTALL_DIR}. Please remove them manually."
                success "Removed existing binaries from ${INSTALL_DIR}"
                return 0
            fi
            error "No uninstaller available and no binaries found in ${INSTALL_DIR}; please uninstall manually."
            ;;
    esac
}

parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                if [ -n "$2" ] && [ "${2#-}" = "$2" ]; then
                    VERSION="$2"
                    shift
                else
                    error "Missing value for --version"
                fi
                ;;
            -d|--dir)
                if [ -n "$2" ] && [ "${2#-}" = "$2" ]; then
                    INSTALL_DIR="$2"
                    shift
                else
                    error "Missing value for --dir"
                fi
                ;;
            -e|--embed)
                if [ -n "$2" ] && [ "${2#-}" = "$2" ]; then
                    EMBED_COMPONENTS="$2"
                    shift
                else
                    error "Missing value for --embed"
                fi
                ;;
            -f|--features)
                if [ -n "$2" ] && [ "${2#-}" = "$2" ]; then
                    FEATURES="$2"
                    shift
                else
                    error "Missing value for --features"
                fi
                ;;
            -r|--ros-distro)
                if [ -n "$2" ] && [ "${2#-}" = "$2" ]; then
                    ROS_DISTRO="$2"
                    shift
                else
                    error "Missing value for --ros-distro"
                fi
                ;;
            -b|--build)
                FORCE_BUILD=1
                ;;
            -y|--yes)
                YES_TO_ALL=1
                ;;
            -n|--no-default-embed)
                NO_DEFAULT_EMBED=1
                ;;
            --)
                shift
                break
                ;;
            -*)
                warn "Unknown option: $1"
                ;;
            *)
                # positional arguments are ignored for now
                ;;
        esac
        shift
    done
}
get_manifest_archives_for_target() {
    MANIFEST_JSON="$1"
    TARGET="$2"
    
    echo "$MANIFEST_JSON" | awk -v tgt="$TARGET" '
    BEGIN { count=0; found_targets=0 }
    
    # Start tracking when we hit "targets": {
    /"targets"[[:space:]]*:/ { found_targets=1 }
    
    found_targets {
        # 1. Update Brace Count
        # We perform substitions on a copy of the line to count braces
        line=$0
        n_open = gsub(/{/, "", line)
        line=$0
        n_close = gsub(/}/, "", line)
        count += n_open - n_close

        # 2. Check for Archive Keys
        # We look for lines like: "minot-target": {
        # We exclude the "targets" line itself
        if ($0 ~ /^[[:space:]]*"[^"]+":[[:space:]]*{/ && $0 !~ /"targets"/) {
             split($0, parts, "\"")
             key = parts[2]
             # Print if the key contains our target string
             if (index(key, tgt) > 0) print key
        }

        # 3. Exit if block is closed
        # If count drops to 0 (and we have started), we are done.
        if (count <= 0) exit
    }'
}

get_manifest_features() {
    MANIFEST_JSON="$1"
    ARCHIVE_NAME="$2"

    echo "$MANIFEST_JSON" | awk -v arch="$ARCHIVE_NAME" '
    # Find the start of the specific archive block
    $0 ~ "\"" arch "\":" { in_block=1; next }
    # If we hit the closing brace of the block, stop
    in_block && /^[[:space:]]*},?/ { exit }
    
    in_block && /"features":/ {
        # Line looks like: "features": ["embed-coord", "embed-ros2-c"],
        # Strip the key
        sub(/"features":/, "")
        # Replace brackets, quotes, and commas with spaces
        gsub(/[\[\]",]/, " ")
        # Print each word on a new line
        for(i=1; i<=NF; i++) if($i!="") print $i
        exit
    }'
}

get_manifest_ros_distro() {
    MANIFEST_JSON="$1"
    ARCHIVE_NAME="$2"

    echo "$MANIFEST_JSON" | awk -v arch="$ARCHIVE_NAME" '
    $0 ~ "\"" arch "\":" { in_block=1; next }
    in_block && /^[[:space:]]*},?/ { exit }
    
    in_block && /"ros_distro":/ {
        # Line looks like: "ros_distro": "jazzy",
        split($0, parts, "\"")
        # parts[1]=spaces, parts[2]=key, parts[3]=Colon, parts[4]=Value
        print parts[4]
        exit
    }'
}

get_manifest_base_target() {
    MANIFEST_JSON="$1"
    ARCHIVE_NAME="$2"
    
    echo "$MANIFEST_JSON" | awk -v arch="$ARCHIVE_NAME" '
    $0 ~ "\"" arch "\":" { in_block=1; next }
    in_block && /^[[:space:]]*},?/ { exit }
    
    in_block && /"requires_base_target":/ {
        split($0, parts, "\"")
        print parts[4]
        exit
    }'
}

main() {
    parse_args "$@"
    
    prompt_uninstall_existing
    detect_ros_from_env_and_prompt
    
    OS_NAME=$(detect_os)
    ARCH_NAME=$(detect_arch)
    
    # musl does not have the shared object of rat, so make it available but not the default
    PREFER_GNU=1
    
    TARGET=$(get_target_triple "$OS_NAME" "$ARCH_NAME" "$PREFER_GNU" ) || true

    info "Detected system: ${CYAN}$OS_NAME${NC} (${CYAN}$ARCH_NAME${NC})"
    if [ -n "$TARGET" ]; then
        info "Target triple: ${CYAN}$TARGET${NC}"
    else
        warn "Could not determine a prebuilt target triple; will build from source"
        FORCE_BUILD=1
    fi
    
    if [ $FORCE_BUILD -eq 0 ]; then
        if [ -z "$VERSION" ]; then
            if ! get_latest_version; then
                FORCE_BUILD=1
            fi
        else
            if ! resolve_requested_version; then
                error "Failed to resolve requested version: $VERSION"
            fi
            info "Installing version: ${CYAN}$VERSION${NC}"
        fi
        
        VERSION_WITH_V="$VERSION"
        if [ -n "$VERSION_WITH_V" ]; then
            case "$VERSION_WITH_V" in
                v*) ;;
                *) VERSION_WITH_V="v$VERSION_WITH_V" ;;
            esac
        fi
        
        MANIFEST_JSON=""
        REQUESTED_FEATURES=""

        if [ -n "$EMBED_COMPONENTS" ]; then
            EMBED_FEATURES=$(embed_to_features "$EMBED_COMPONENTS")
            if [ -n "$FEATURES" ]; then
                REQUESTED_FEATURES="${FEATURES},${EMBED_FEATURES}"
            else
                REQUESTED_FEATURES="$EMBED_FEATURES"
            fi
        elif [ -n "$FEATURES" ]; then
            REQUESTED_FEATURES="$FEATURES"
        fi

        if [ "$NO_DEFAULT_EMBED" -eq 0 ]; then
             case ",$REQUESTED_FEATURES," in
                *,embed-coord,*) ;;
                *)
                    if [ -n "$REQUESTED_FEATURES" ]; then
                        REQUESTED_FEATURES="embed-coord,${REQUESTED_FEATURES}"
                    else
                        REQUESTED_FEATURES="embed-coord"
                    fi
                    ;;
            esac
        fi

        if [ -n "$ROS_DISTRO" ]; then

            ROS_DISTRO_LC=$(echo "$ROS_DISTRO" | tr '[:upper:]' '[:lower:]')
            ROS2_C_FEATURE="embed-ros2-c"

            if [ "$ROS_DISTRO_LC" = "humble" ]; then
                # Wenn ja, fgen wir "-humble" hinzu
                ROS2_C_FEATURE="${ROS2_C_FEATURE}-${ROS_DISTRO_LC}"
            fi
            
            case ",$REQUESTED_FEATURES," in
                *,${ROS2_C_FEATURE},*|*,embed-ros,*|*,embed-ros2-c,*) ;;
                *)
                    if [ -n "$REQUESTED_FEATURES" ]; then
                        REQUESTED_FEATURES="${REQUESTED_FEATURES},${ROS2_C_FEATURE}"
                    else
                        REQUESTED_FEATURES="${ROS2_C_FEATURE}"
                    fi
                    ;;
            esac
        fi

        MANIFEST_JSON=$(get_release_manifest "$VERSION_WITH_V")
        if [ -z "$MANIFEST_JSON" ]; then
            if [ -n "$ROS_DISTRO" ]; then
                ARCHIVE_NAME="minot-${ROS_DISTRO}-${TARGET}"
            else
                ARCHIVE_NAME="minot-${TARGET}"
            fi
        else
            SELECTED=$(select_best_archive "$MANIFEST_JSON" "$TARGET" "$REQUESTED_FEATURES" "$ROS_DISTRO") || true
            if [ -n "$SELECTED" ]; then
                ARCHIVE_NAME="$SELECTED"
            else
                # Enable this temporarily to debug
                # info "DEBUG: Failed to select archive. Target=$TARGET ReqFeatures=$REQUESTED_FEATURES Ros=$ROS_DISTRO"
                info "Falling back to building from source; no suitable prebuilt binary found."
                FORCE_BUILD=1
            fi
        fi
        
        if [ -n "$MANIFEST_JSON" ]; then
            BINARY_ROS_DISTRO=$(get_manifest_ros_distro "$MANIFEST_JSON" "$ARCHIVE_NAME")
            if [ -n "$BINARY_ROS_DISTRO" ]; then
                if ! check_ros_distro_available "$BINARY_ROS_DISTRO"; then
                    warn "ROS ${BINARY_ROS_DISTRO} not found"
                    error "Cannot use prebuilt binary without ROS ${BINARY_ROS_DISTRO}."
                fi
            fi
        fi
        
        if [ $FORCE_BUILD -eq 0 ] && check_binary_exists "$TARGET" "$ARCHIVE_NAME" "$VERSION_WITH_V"; then
            success "Found prebuilt binary: ${CYAN}${ARCHIVE_NAME}${NC}"
            
            BASE_ARCH_NAME=""
            if [ -n "$MANIFEST_JSON" ]; then
                BASE_ARCH_NAME=$(get_manifest_base_target "$MANIFEST_JSON" "$ARCHIVE_NAME" || true)
            fi

            if ! download_and_install "$TARGET" "$ARCHIVE_NAME" "$BASE_ARCH_NAME" "$VERSION_WITH_V" "$REQUESTED_FEATURES"; then
                warn "Installing prebuilt binary failed  will fall back to building from source"
                FORCE_BUILD=1
            fi
        elif [ $FORCE_BUILD -eq 0 ]; then
            warn "No prebuilt binary found for your system"
            if [ -n "$ROS_DISTRO" ]; then
                info "ROS ${CYAN}${ROS_DISTRO}${NC} build not available for ${CYAN}${TARGET}${NC}"
            fi
            
            if [ $YES_TO_ALL -eq 0 ]; then
                printf "\n"
                prompt "Would you like to build from source? [Y/n]"
                if ! safe_read response; then
                    error "Installation cancelled."
                fi
                case "$response" in
                    [nN][oO]|[nN]) error "Installation cancelled" ;;
                    *) FORCE_BUILD=1 ;;
                esac
            else
                FORCE_BUILD=1
            fi
        fi
    fi
    
    if [ $FORCE_BUILD -eq 1 ]; then
        printf "\n"
        build_from_source
    fi
    
    suggest_path_update
    printf "\n${BOLD}Next steps:${NC}\n"
    printf "  ${GREEN}1.${NC} Verify installation: ${CYAN}minot --help${NC}\n\n"
}

main "$@"
