// Example of rats (.rat -- Rats Language)
#rats <- flio, mlio

==._print <- false
==._verbose <- true
  
[bacon2]
flio -> mlio

[bacon1]
C <- ._num_call
if C > 10 {
  flio <- mlio
}

[bacon3]
==._print <- true
==._verbose <- true

==

// Lexer
[
  bacon2
  ->
  $flio
  $mlio
]

[
  bacon1
  <-
  C
  ._num_call
  if
  C > 10
  {
    $flio <- $mlio
  }
]


// runs network here

#dbg
play_frames l 10
play_frames m 10 l
play_frames o 100

reset

// optimize on chef rat
#rats <- sfasterlio_cpu, sfasterlio_gpu

[check1]
._act <- param_opt

[[param_opt]]
+ -> .check1.accuracy
.check1.accuracy.min <- 10cm
~ -> .check1.accuracy.max

// act by changing parameters only
.map_voxel_size <- 10cm .. 25cm

[rcc <- report(check1, check2)]
._print <- false // disable printing report to console or TUI
._act <- method_switch // handle must be an act bacon

[[method_switch]]
.rcc.time <- ---
.rcc.cpu_usage <- ~
.rcc.memory_mb <- -

._choice.choices.MappingOnly.sfasterlio_cpu.weight <- 0
._choice.choices.ActiveRegistration.switch_weight <- 1
._choice.choices.Inactive.switch_weight <- 3

._choice.keep_min <- 4s // minimal time to keep this choice before evaluating the report

// !! NetworkShipImpl and ThreadShipImpl


// optimize on network or "lego lio" -> switch variables to different methods, optimize over best combination of methods.
// Does not work because both methods still run. Only makes sense when it is possible to skip work between bacons.
// "goto" can do that but then we may jump over variable initialisations etc.

