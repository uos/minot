var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>Minot [mai\u00b7not] provides primitives for developing and validating stateful robot software.</p> <p>When developing, we want to solve a small problem that plays nicely with the larger system. Modularity is one of the main goals of ROS. And while developing and integrating these modules, Minot is here to help.</p> <p>The Pain Leading to Minot</p> Message TimingIgnore NetworkingReproducability <p>Does your system behave different each time you play a Bagfile until you find out it actually works when playing it a little bit slower?</p> <p>Have you ever asked yourself why you should care about QoS settings, out-of-order message pipelines or the dependency of ROS2 itself when developing a Proof of Concept?</p> <p>Did you ever develop a ROS Node with state that unexpectedly changes for some reason and now you try to reproduce it?</p> <p>All the provided features are meant to be used at development time to give you full control over the incoming data. It gives you transparency for complex systems where thousands of small sensor data packets are processed each second. With Minot, you regain control and explainability over what's happening when developing and integrating your Robot.</p>"},{"location":"index.html#first-look","title":"First Look","text":"<p>The following example gives you a general idea of what Minot can do.</p> <p></p> <p>Click the image to explore it in more detail.</p> <p>Note</p> <p>This example just showcases just a selection of Minot's features, but it demonstrates a pipeline I've found particularly helpful and, I believe, will benefit others.</p> <p>You are looking at a bugged Lidar Inertial Odometry (LIO) ROS2 node. For IMU initialisation, only the necessary frames are played from a Bagfile to the node. </p> <p>We synchronise the Bagfile with our node using a unique approach: an empty variable in the LIO acts as a trigger for publishing a new batch of messages. This triggers the registration part in the LIO, which then triggers the variable again, creating an endless loop. Thanks to Minot's locking feature, the process doesn't need to run until the end of the Bagfile; we can press comma (<code>,</code>) on the keyboard to advance to the next registration, or stop it entirely to compare and visualize the state using debuggers, visualizers, or logging to the TUI.</p> <p>Notably, everything is running natively on a Macbook with no containers or ROS installation.</p> <p>How?</p> <p>Minot is a collection of binaries and libraries. They can be used in your existing ROS1 or ROS2 nodes or completely separate from any system. This allows cross-ROS communication using its own networking layer without adding dependencies. With Minot you can also write, test and debug ROS perception nodes without needing ROS on your system (currently Rust-only). This is especially useful for testing, where determinism is essential. When you are done, just comment out a few lines or change a compile flag and you are ready to run your node in ROS.</p> <p>There are 3 features. They can be used standalone but when combined, they enable superpowers.</p>"},{"location":"index.html#bagfile-querying","title":"Bagfile Querying","text":"<p>With ROS you can record and play everything published to the ROS network. This enables reproducability for nodes and greatly improves the safety of developing real robots. Bagfiles are great! But the ROS tooling for playing the Bagfile is limited. It's still enough for most use cases but there are times where you need complete control over the data that is published to your subscribers. Minot packages a (kind of) query language for fine grained filtering and cursor control inside your Bagfile for fast iterations. This is Bagfile Querying in Minot.</p> <p>It introduces a small, embedded language and functions for maximal control over your node while keeping flexibility. For more information, visit the feature page.</p>"},{"location":"index.html#quickstart","title":"Quickstart","text":"Ubuntu 24.04 + JazzyUbuntu 22.04 + Humble Setup<pre><code>mkdir minot-bagfile-demo &amp;&amp; cd minot-bagfile-demo\nsource /opt/ros/jazzy/setup.bash\nsudo apt install rustup curl unzip\n\n# Get Minot with ROS2 publisher\ncargo install \\\n  --git https://github.com/uos/minot minot \\\n  --locked \\\n  --features embed-ros2-c\n\n# Get a Bagfile saved with mcap storage\ncurl -Lo dlg_cut.zip \"https://myshare.uni-osnabrueck.de/f/5faf4154af384854ab94?dl=1\" \\\n    &amp;&amp; unzip dlg_cut.zip \\\n    &amp;&amp; rm dlg_cut.zip\n\n# Get the query\ncurl -Lo demo.rl \"https://uos.github.io/minot/assets/demo_publish.rl\"\n\n# Get the rviz demo preset\ncurl -Lo demo.rviz \"https://uos.github.io/minot/assets/demo_publish.rviz\"\n\n# Run rviz and wait for data\nrviz2 -d demo.rviz\n</code></pre> <p>Make sure you have Rust installed. Setup<pre><code>mkdir minot-bagfile-demo &amp;&amp; cd minot-bagfile-demo\nsource /opt/ros/humble/setup.bash\nsudo apt install curl unzip\n\n# Get Minot with ROS2 publisher\ncargo install \\\n  --git https://github.com/uos/minot minot \\\n  --locked \\\n  --features embed-ros2-c-humble\n\n# Get a Bagfile saved with mcap storage\ncurl -Lo dlg_cut.zip \"https://myshare.uni-osnabrueck.de/f/5faf4154af384854ab94?dl=1\" \\\n    &amp;&amp; unzip dlg_cut.zip \\\n    &amp;&amp; rm dlg_cut.zip\n\n# Get the query\ncurl -Lo demo.rl \"https://uos.github.io/minot/assets/demo_publish.rl\"\n\n# Get the rviz demo preset\ncurl -Lo demo.rviz \"https://uos.github.io/minot/assets/demo_publish.rviz\"\n\n# Run rviz and wait for data\nrviz2 -d demo.rviz\n</code></pre></p> <p>Open a new terminal. Run Minot TUI<pre><code>source /opt/ros/$ROS_DISTRO/setup.bash\n\n# Run\nminot demo.rl\n\n# Press w and then Space\n# You should see a 3D Pointcloud in rviz2 now.\n# Press j until you see \"W3\" in the bottom right.\n# Press Space again to evaluate line 3 of demo.rl and repeat how often you like.\n# Quit Minot with q\n\n# Clean up everything we created\ncd .. &amp;&amp; rm -rf minot-bagfile-demo &amp;&amp; cargo uninstall minot\n</code></pre></p>"},{"location":"index.html#variable-sharing","title":"Variable Sharing","text":"<p>One of the main tasks of the ROS Pub/Sub system (excluding non-sensor pipelines with actions and service) is sharing a new value of something. At development time, when accuracy is at the highest priority, this async model might be in your way.</p> <p>With librat, you can share variables synchronously over the network. It is library written in Rust but targeted at C. It's built for the absolute minimal user footprint. You initialise it once and then give it any variables to cling to without changing anything else in your existing code. Just look at the header file. You then explain the routes to the Minot TUI with intuitive syntax.</p> <p>Variable sharing is a powerful building block and it can easily be used outside of the ROS context. Click here to learn more.</p> <p>From Comparing to full E2E Testing</p> <p>By just writing a \"proc1 == proc2\", and adding 4 lines of code in total, you can check the equality of a variable from two different processes (proc1, proc2) that don't need to share the language or system. Comparing is just syncing both variables with the TUI.</p> <p>This also effectively describes a unit test over the network. And together with using checkpoints as trigger for a Bagfile publish, Minot effectively gives you an entire E2E testing framework for ROS networks.</p>"},{"location":"index.html#quickstart_1","title":"Quickstart","text":"<p>Build and run the libraries and run the Coordinator.</p> <pre><code>git clone https://github.com/uos/minot &amp;&amp; cd minot\ncargo build --release\n\n./target/release/minot-coord rl/varshare_demo.rl\n</code></pre> <p>Start a second terminal to run rat1 in Rust. <pre><code>cargo run --example rat1\n</code></pre></p> <p>Start a third terminal to build and run rat2 in C.</p> <pre><code>gcc rat/examples/rat2.c -o rat2 -L./target/release -l:librat.a -lm -Wl,-z,noexecstack\n\n./rat2\n\n# rat1 and rat2 terminate successfully.\n# Look at the source code of the C file you just compiled.\n# rat1 just flipped the 0 from rat2 to 1.\n\n# Clean up\ncd .. &amp;&amp; rm -rf minot\n</code></pre>"},{"location":"index.html#native-publishsubscribe","title":"Native Publish/Subscribe","text":"<p>The Pub/Sub model has proven itself among ROS developers. It's an intuitive way to exchange time series data. But sometimes adding the entire ROS stack with all its solutions for problems outside of the domain of the problem your node tries to solve seems like overkill.</p> <p>For these cases, the native publisher and subscriber Rust library ratpub can help. By building on the same concepts as Variable Sharing, it removes ROS from the dependency list at development time if you only use that API from ROS. Read more about it here.</p> Quickstart<pre><code># Clone the example nodes\ngit clone https://github.com/stelzo/ratpub-demo &amp;&amp; cd ratpub-demo\n\n# Install the Coordinator\ncargo install \\\n  --git https://github.com/uos/minot minot \\\n  --locked\n\n# Run it\nminot-coord\n</code></pre> <p>Start a second terminal to run the a node. <pre><code>cargo run --bin node1\n</code></pre></p> <p>Start a third terminal another one. <pre><code>cargo run --bin node2\n</code></pre></p> <p>Exit everything with Ctrl+C. Then cleanup everything we created: <code>cd .. &amp;&amp; rm -r ratpub-demo &amp;&amp; cargo uninstall minot</code>.</p> <p>Find out how this nodes works and how to write them here.</p>"},{"location":"bagquery.html","title":"Bagfile Query","text":"<p>While developing ROS nodes, Bagfiles can help you a lot for reproducability. With Minot you can query that recording and control each message that is published to your nodes. Bagfile Query is not built for a long stream of data. The idea is to grab specific chunks that fit some query and send them via the Coordinator (like a ROS1 Master) to all connected nodes that care about publishing Bagfile data. It is not meant to be a replacement for <code>ros2 bag play</code>. If you just want to play a Bagfile, we recommend the usual ROS tooling.</p> <p>To establish the power of querying, we will start off by implementing <code>bag play</code> in Minot and then go from there.</p> <p>First off you need the Minot TUI binary. It expects a Ratslang file (<code>.rl</code>) as the first argument. You will need the line numbers of that file while interacting with Minot TUI at the same time so keep them both open side by side.</p> <p>Ratslang</p> <p>Ratslang is a minimal configuration language that inherently handles units. You should be able to read and speak it fluently by reading the 20 line example here.</p> <p>Minot extends Ratslang with some functions that are built right into the language. They are used for querying the bagfile.</p>"},{"location":"bagquery.html#reset","title":"<code>reset!</code>","text":"<p>Load a Bagfile set the cursor to the beginning.</p> <p>This function requires a path to a Bagfile (directory name). The path is relative to your current working directory where you started the Minot TUI.</p> Definition<pre><code>reset! &lt;Path&gt;\n</code></pre> Example<pre><code>reset! ./mybag\n</code></pre> <p>Warning</p> <p>At the moment, we only support the MCAP storage backend. It is the default for Rosbags since ROS2 Iron Irwini. For older Bagfiles, follow the conversion guide here.</p>"},{"location":"bagquery.html#pf","title":"<code>pf!</code>","text":"<p>Play frames (messages) from the currently loaded Bagfile.</p> Definition Normal<pre><code>pf! &lt;Topics&gt; &lt;Span&gt; [&lt;PlayingSpan&gt; [&lt;Trigger&gt;]] \n</code></pre> Definition Conditional<pre><code>pf! &lt;Topics&gt;, &lt;UntilTopics&gt; &lt;UntilCondition&gt; [&lt;PlayingSpan&gt; [&lt;Trigger&gt;]] \n</code></pre> Definition Primitives<pre><code>&lt;UntilTopics&gt; := &lt;Topics&gt;\n&lt;Topics&gt; := Array&lt;TopicIdentifier&gt; | &lt;TopicIdentifier&gt;\n\n&lt;PlayingSpan&gt; := &lt;RelativeSpan&gt; | &lt;Factor&gt;\n&lt;Factor&gt; := &lt;Float&gt;\n\n&lt;Span&gt; := &lt;AbsoluteSpan&gt; | &lt;RelativeSpan&gt;\n&lt;AbsoluteSpan&gt; := [&lt;Time&gt;]..[&lt;Time&gt;]\n&lt;RelativeSpan&gt; := &lt;Time&gt;\n\n&lt;Trigger&gt; := &lt;TriggerVariable&gt; [&lt;TriggerMode&gt;]\n&lt;TriggerVariable&gt; := &lt;String&gt;\n&lt;TriggerMode&gt; := d | f\n</code></pre> <p>The <code>&lt;TriggerMode&gt;</code> specifies dynamic dispatch with <code>d</code> and fixed with <code>f</code>. When not specified, dynamic is assumed. Dynamic dispatch means the Coordinator will ask the TUI to evaluate the query when reaching the variable. Fixed mode will evaluate the query first and publish the same messages everytime it reaches the variable.</p> <p><code>&lt;TriggerVariable&gt;</code> must correspondend to a variable set in the rules for sharing variables. Click here for more information.</p> <p><code>&lt;TriggerVariable&gt;</code> is defined by the user using Ratslang. There is an existing struct format Minot is looking for. It looks like this:</p> Setting TopicIdentifier<pre><code>_bag.{\n\n  yourchosenname.{\n    _topic = &lt;Path&gt;\n    _short = &lt;String&gt;\n    _type = Cloud|Imu|Any\n  }\n\n  yournexttopic.{\n    ...\n  }\n\n  ...\n}\n</code></pre> <p>Every new namespace you define in <code>_bag</code> will be checked for <code>_topic</code>, <code>_short</code> and <code>_type</code>. You can interpret this as configuring an Array of Structs without having Structs in the language.</p> <p><code>yourchosenname</code> is a filler for any name you choose to call this TopicIdentifier. You can then use that name inside your <code>pf!</code> function.</p> <p>When debugging something with fast iterations, it is often convenient to abbreviate your names. With <code>_short</code> you can give your identifier an alternative name.</p> <p><code>_type</code> is one the main interests for Minot when querying. It matches the given type to the message at the current cursor position. <code>_type</code> is one of \"Cloud\", \"Imu\" or \"Any\". They can easily be extended to more messages as needed. A type is necessary as soon as you want to publish messages outside of ROS2 installations. Cloud relates to <code>sensor_msgs/msg/PointCloud2</code> and Imu to <code>sensor_msgs/msg/Imu</code>.</p> <p>Any will match every message. In the installation, this behaviour is defined as with or without any-type. By specifying an exisiting type, Minot can use it outside of ROS2 land. For example in ROS1 or the the Native Pub/Sub library.</p> <p><code>_topic</code> allows for more detailed message matching. When you got multiple Imu topics in your Bagfile, this parameter becomes essential.</p> Multiple Types and QoS per Topic <p>ROS2 allows many publishers to the same topic with different types and QoS settings. Minot assumes a simple environment, where a topic is always published by one publisher with one QoS. While multiple publishers work with Minot, it itself only uses a single publisher with one QoS, which still works for common multi-publisher systems like TF.</p> <p>Conditional Queries are a special form of <code>&lt;Span&gt;</code> but it also disables some combinations that make no sense in this context so they will fail with an error. There is only one important consideration when using Conditionals: they are exclusive. So a query like <code>pf! x, y 1</code> will stop the cursor right before the <code>y</code> topic. You can consume it then with any other query since they are inclusive. Like a fxied number: <code>pf! y 1</code>.</p> <p>Now we got everything we need to implement the <code>ros2 bag play</code> command within Minot.</p> ros2 bag play ./bagfile<pre><code># Define our topic filter\n_bag.any._type = Any\n\n# Load the bagfile\nreset! ./bagfile\n\n# Play everything at original speed\npf! any .. 1.\n</code></pre> <p>Warning</p> <p>With this code, Minot will load the entire Bagfile into memory first, which is probably not want you want. This is why you should still use <code>ros2 bag play</code> for this use case -- but it beautifully demonstrates the flexibility of Minots query feature.</p> <p>If you can understand this, you are ready for some more examples.</p>"},{"location":"bagquery.html#examples","title":"Examples","text":"demo.rl<pre><code>_bag.{\n  lidar.{\n    _topic = \"/velodyne_points\"\n    _type = Cloud\n    _short = \"l\"\n  }\n  imu.{\n    _topic = \"/imu/data\"\n    _type = Imu\n    _short = \"i\"\n  }\n}\n\n# send all lidar frames between the time of 10s and 20s of the bagfile immediately\npf! l 10s..20s\n\n# send all lidar and imu frames between the time of 10s and 20s of the bagfile when reaching var1\npf! [l, i] 10s..20s var1\n\n# send all lidar frames between the time of 10s and 20s of the bagfile but slow down time so it sends it over 2 minutes\npf! l 10s..20s 2mins\n\n# send the next imu frames until 2 lidar frames are encountered\npf! i, l 2\n\n# send the next 10 lidar frames but spread them out over 20s\npf! l 10 20s\n\n# send the next 10 seconds of lidar frames everytime a rat reaches var1\npf! l 10s var1\n</code></pre> <p>For information on how to execute the code in Minot TUI, click here.</p>"},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>Binaries for common system configurations are available here.</p> <p>The <code>minot-$ROS_DISTRO-*</code> archives will only give you ROS specific binaries:</p> <ul> <li><code>minot</code> TUI + Coordinator + ROS2 Publisher (with any-type)</li> <li><code>wind-ros2-c</code> Standalone ROS2 Publisher (with any-type)</li> </ul> <p>Archives not specific to a ROS distribution contain builds that can be used independently.</p> <ul> <li><code>minot</code> TUI + Coordinator</li> <li><code>minot-coord</code> Standalone Coordinator</li> <li><code>librat.*, rat.h</code> C libraries for Variable Sharing</li> <li><code>wind-ros*-native</code> ROS Publisher using roslibrust for ROS1 and ros2-client for ROS2</li> </ul> <p>While the prebuilt binaries cover many common use cases, you may need to build Minot from source to tailor it to your specific needs. Building from source requires the Rust toolchain to be installed on your system.</p>"},{"location":"installation.html#minot-tui","title":"Minot TUI","text":"<p>To build the Minot TUI, there are some feature flags for embedding common network participants for convenience. A detailed list of supported flags can be found in the Minot features definition.</p> <p>With default settings, Minot builds with an integrated coordinator. When running the following command with no changes, you will get a <code>minot</code> binary with integrated Coordinator and a <code>minot-coord</code> binary, that is just a Coordinator. The standalone Coordinator is enough for sharing variables with the rat library.</p> Publishing custom and any-type messages <p>Publishing any-type messages from a Bagfile (like <code>ros2 bag play</code>) needs the ROS2 C implementation to be linked to the message. When building the Rust bindings, it will link with every message in your <code>$PATH</code>. So if you use custom messages, you want to build Minot after you sourced your new message.</p> <p>To help you get up and running quickly, here are some popular configurations.</p> (Recommended) With ROS2 publisher (+ any-type, needs sourced ROS2)<pre><code>cargo install \\\n  --git https://github.com/uos/minot minot \\\n  --locked \\\n  --features embed-ros2-c\n</code></pre> <p>The next version does not need any ROS1 or ROS2 installation to compile but it expects to find a node in the network if you try to query a Bagfile:</p> Minimal with embedded Coordinator<pre><code>cargo install \\\n  --git https://github.com/uos/minot minot \\\n  --locked\n</code></pre> <p>Or maybe you want to publish to ROS1 and ROS2 at the same time without needing a ROS installation. Since the input is always a ROS2 Bagfile, only mapped types can be published (no any-type).</p> With ROS1 and ROS2 publishers<pre><code>cargo install \\\n  --git https://github.com/uos/minot minot \\\n  --locked \\\n  --features embed-ros-native\n</code></pre>"},{"location":"installation.html#standalone-coordinator","title":"Standalone Coordinator","text":"<p>Installing Minot TUI as shown above will also build a standalone variant of the Coordinator. It is called <code>minot-coord</code> in your path.</p>"},{"location":"installation.html#standalone-wind-turbines-bagfile-publishers","title":"Standalone Wind Turbines (Bagfile Publishers)","text":"<p>Tip</p> <p>You can compile the embedded publishers standalone and distribute them in your network.</p> <p>For example: you could run the TUI on a Mac, connected to a Robot with a Raspberry Pi over Wi-Fi or LAN, which runs ROS1 or ROS2 and the wind nodes.</p> <p>Standalone publishers live inside the <code>wind</code> module. You can compile/install them to your <code>$PATH</code> by changing the previous command from <code>minot</code> to <code>wind</code>.</p> <p>With <code>--all-features</code>, you'll get all binaries but you need to have ROS2 sourced.</p> Standalone Publishers (needs sourced ROS2)<pre><code>cargo install \\\n  --git https://github.com/uos/minot wind \\\n  --locked \\\n  --all-features\n</code></pre> <p>The following flavours are available for publishing bagfile messages when specifying the respective feature:</p> <ul> <li>wind-ros2-c (with any-type) <code>--feature ros2-c</code></li> <li>wind-ros1-native <code>--feature ros1-native</code></li> <li>wind-ros2-native <code>--feature ros2-native</code></li> <li>wind-rat <code>--feature ratpub</code></li> </ul> <p>Only the C version requires a ROS2 installation at compile time.</p>"},{"location":"installation.html#rats-variable-sharing","title":"Rats (Variable Sharing)","text":"<p>Nodes in the Minot network are called Rats (here is why). The functionality is shipped as a Rust and C library.</p> <p>You need to build the library from source. It generates a static and shared library in the <code>./target/release/</code> folder. You will need to clone the repository first.</p> Build librat from source<pre><code>git clone https://github.com/uos/minot\ncd minot\ncargo build --package rat --release\n</code></pre> <p>A typical system-wide installation is to copy the libraries to your linker path. Alternatively, you may change the link path and include search paths in your build system.</p> <pre><code>sudo cp ./target/release/librat.* /usr/local/lib/\nsudo mkdir -p /usr/local/include/rat/\nsudo cp ./rat/rat.h /usr/local/include/rat/\n</code></pre> <p>Then you can use the library in your C/C++ code. <pre><code>#include &lt;rat/rat.h&gt;\n</code></pre></p> <p>And link with <code>-lrat</code>.</p> <p>For using the Rust library, just add this to your dependencies in <code>Cargo.toml</code>.</p> Cargo.toml<pre><code>rat = { version = \"0.1.0-rc.4\", git = \"https://github.com/uos/minot\" }\n</code></pre>"},{"location":"installation.html#ratpub-native-publishsubscribe","title":"Ratpub (Native Publish/Subscribe)","text":"<p>Ratpub is only available for Rust. It uses Tokio for async I/O. For using the library in your project, add these lines to your dependencies in <code>Cargo.toml</code>.</p> Cargo.toml<pre><code>ratpub = { version = \"0.1.0-rc.4\", git = \"https://github.com/uos/minot\" }\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre> <p>Since you probably want to use existing ROS2 message definitions, you can also add the following crate which is auto-generated from the Jazzy release. It bundles all usual types and implements the required <code>rkyv</code> traits for sending them over the Minot network.</p> Cargo.toml<pre><code>ros2-interfaces-jazzy-rkyv = { version = \"0.0.4\", features = [\n  \"std_msgs\", # add more here\n], git = \"https://github.com/stelzo/ros2-interfaces-jazzy-rkyv.git\" }\n</code></pre> <p>Learn more on how to use it in your Code by visiting the feature page.</p>"},{"location":"installation.html#uninstall","title":"Uninstall","text":"<p>With modern software the word \"installing\" is overloaded. Cargo just compiles the code and moves the finished binaries to <code>~/.cargo/bin</code>. There are no other side effects or files from Minot.</p> <p>If you want to remove them with cargo, you can <code>cargo uninstall minot</code> or <code>cargo uninstall wind</code> and they are gone.</p>"},{"location":"keybindings.html","title":"Keybindings","text":"<p>Keybindings for the Minot TUI. They cannot be changed after compile time for the moment.</p>"},{"location":"keybindings.html#basics","title":"Basics","text":"Command Key Quit q, Esc, Ctrl+c Toggle Log Window ? Switch Mode (Wind/Compare) w"},{"location":"keybindings.html#wind-cursor","title":"Wind Cursor","text":"Command Key Move Cursor up k, \u2191 Move Cursor down j, \u2193 Toggle Goto Line Window (in wind mode) g Apply Goto Line Input Enter Select All Lines * Toggle Select Mode (in wind mode) v Compile and Run Selection (in wind mode) Space"},{"location":"keybindings.html#rules","title":"Rules","text":"Command Key Clear (in compare mode) Space <p>Adding new ones happens automatically when firing the <code>.rl</code> file if it contains some.</p>"},{"location":"keybindings.html#matrix-compare-window","title":"Matrix Compare Window","text":"Command Key Move Cursor Left (in compare mode) h, \u2190 Move Cursor Up (in compare mode) k, \u2191 Move Cursor Down (in compare mode) j, \u2193 Move Cursor Right (in compare mode) l, \u2192 Toggle Cursor Popup (in compare mode) g Apply Current Input in Popup Enter Scroll History Older Shift+Tab Scroll History Newer Tab Swap Compare Buffers Shift+f Move Through Rats at Current Var PageUp / PageDown Unlock Vars . Lock Next Var - Unlock Until Next Var (Step forward) , Increase Left Window Column Width Ctrl+q Decrease Left Window Column Width Ctrl+a Increase Right Window Column Width Ctrl+w Decrease Right Window Column Width Ctrl+s"},{"location":"keybindings.html#difference-tolerance","title":"Difference Tolerance","text":"Command Key Increase at Current Cursor Shift+t Decrease at Current Cursor t Move Cursor Left p Move Cursor Right Shift+p"},{"location":"lore.html","title":"Lore","text":"<p>You might wonder about the unusual names used in Minot.</p> <p>The simple answer is greppability. Minot is designed for use during development. As it's an external system, I made a few assumptions:</p> <p>You'll likely want to remove Minot before releasing your software. You'll also need to quickly locate Minot calls. Since words like bacon or rat are probably uncommon in your production code, Minot can use them without conflict. This makes them easy to find with a project-wide text search.</p> <p>However, there's a more interesting story behind the names.</p> <p></p> <p>Minot is named after Minot's Ledge Lighthouse near Boston (see Wikipedia). Early versions of the lighthouse didn't last, so a new one was built with a solid granite base. This formidable structure, standing alone at the edge of shallows, was a statement of permanence. Completed in 1860, it still stands today.</p> <p>Info</p> <p>There are local stories and songs about this lighthouse, which I recommend for unwinding after a long day of working with robot algorithms. The image on the right is from a storm in 1978, photographed by Kevin Cole.</p> <p>The lighthouse symbolises coordination at sea\u2014a beacon of hope and safety amid chaos. In contrast to this stability, there are ships navigating rough seas, battling strong winds. Wind is a metaphor for Bagfile data that propels the Ships (our Nodes). The Wind is generated by Turbines (the bagfile publisher nodes). The internal networking library is called Sea, which is self-explanatory.</p> <p>Every Ship (Node) has Rats on board because, during development, a Ship isn't production-ready and still has issues. Rats love Bacon (variables), and when they find Bacon they want to tell their friends and share. So, they use a Cannon on your ship to shoot and retrieve Bacon from one ship to another\u2014across the Sea (network). The Coordinator (lighthouse) oversees everything. While many of these names don't appear in the user-facing API, you'll find these concepts throughout the source code.</p> <p>This story should also make the name of the configuration language, Ratslang, self-explanatory.</p> <p>I like the idea of installing Rats on your Ship to help you stabilize its voyage. Rats do the dirty work by just liking Bacon and being proud of finding it. And once everything is working, you simply remove the Rats again, and your Ship is like new. But now its ready to sail with much more stability.</p>"},{"location":"pubsub.html","title":"Native Pub/Sub","text":"<p>An async implementation of a basic Publish/Subscribe pattern with a ROS-like API.</p> <p>Currently not compatible with C</p> <p>The library for Native Publish/Subscribe is currently only available in Rust because of decisions made for minimal overhead in serialisation/deserialisation. It also not planned to support C or C++ any time soon.</p> <p>While Bagfile Query and Variable Sharing are the main features of Minot, this library is just a small cherry on top. The <code>ratpub</code> library uses existing networking primitives from Variable Sharing like Rats and dynamic Rules and implements a minimal Publish/Subscribe pattern on top of it.</p> <p>When used in static and simple environments (no lifecycle node, assuming stable network and more), it is stable enough for replacing the ROS2 Publish/Subscribe API. But it is absolutely not on par with ROS features.</p> <p>After adding the library to your Cargo.toml, you can create a publisher and a subscriber. Like in ROS1, the communication needs a Master. In this case it is our Coordinator, which we can run standalone without any arguments.</p> Start the Coordinator in your Shell<pre><code>minot-coord\n</code></pre> <p>The example uses pre-generated messages that ship with ROS2 Jazzy to already give you the types you typically use in your Node. If that is not enough, you can add your own types that implement <code>Serialize</code>, <code>Deserialize</code> and <code>Archive</code> from <code>rkyv</code>.</p> publisher.rs<pre><code>use ratpub::Node;\nuse ros2_interfaces_jazzy_rkyv::std_msgs::msg;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // env_logger::init(); // some useful output when running: RUST_LOG=info cargo run \n\n    // Resolves when connected to the Coordinator\n    let node = Node::create(\"my_node_pub\".to_owned()).await?;     \n\n    let pubber = node\n        .create_publisher::&lt;msg::String&gt;(\"/some_topic\".to_owned())\n        .await?;\n\n    let msg = msg::String {\n        data: \"Hello World \ud83d\udd96\".to_owned(),\n    };\n\n    loop {\n        pubber.publish(&amp;msg).await?;\n        sleep(Duration::from_secs(1)).await;\n    }\n}\n</code></pre> <p>Info</p> <p>Nodes will automatically detect the Coordinator and do not need any setup. Like the other networking stack from Minot, you just need to ensure that each Node that you want to connect with each other is reachable in the network.</p> <p>In contrast to Variable Sharing, the publisher does not care about syncing with the subscriber. But like most abstractions, this comes at a cost. Here it is setting the capacity of the queue length for the subscriber - like in ROS.</p> subscriber.rs<pre><code>use ratpub::Node;\nuse ros2_interfaces_jazzy_rkyv::std_msgs::msg;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // env_logger::init();\n\n    let node = Node::create(\"my_node_sub\".to_owned()).await?;\n\n    let mut subber = node\n        .create_subscriber::&lt;msg::String&gt;(\"/some_topic\".to_owned(), 10)\n        .await?;\n\n    while let Some(msg) = subber.next().await {\n        println!(\"Received Message: {}\", &amp;msg.data);\n    }\n\n\n    Ok(())\n}\n</code></pre> <p>Mind that we don't need to <code>spin_once</code> here thanks to async like in other Rust ROS libraries.</p> <p>Unstable Networks</p> <p>In the current state, <code>ratpub</code> should only be used in stable networks. There are still use cases that break your expectations. These problems are planned to get fixed though.</p> <p>Examples</p> <ul> <li>If a publisher dies or disconnects in an existing Pub/Sub connection the subscriber will never get messages on this topic again, even when the publisher comes back or other ones still publish on that topic.</li> <li>Loosing connections to the Coordinator at runtime will result in an error. <code>ratpub</code> is therefore not really reliable in unrealiable networks like Wi-Fi.</li> <li>Nodes are always talking to the Coordinator, which is a good feature for reconfigurable topics but also adds latency. The plan is to add static and dynamic topics, where both have the same features but both have better latency for their respective use case.</li> </ul>"},{"location":"tui.html","title":"Minot TUI","text":"<p>TUI stands for Terminal User Interface. In Minot, it functions as a dashboard with commands for controlling the features. It's the primary way you interact with Minot.</p> <p>After installing the binary with your chosen embeddings, you can run the TUI with: <pre><code>minot [&lt;Path&gt;]\n</code></pre></p> <p>The Path is optional. It defines the Ratslang file for Bagfile Querying and Variable Sharing.</p> <p>On startup, Minot searches for a Coordinator. If you embedded one in the binary (the default setting), it will be found immediately, and the following interface will appear.</p> <p></p> <p>The freshly opened TUI with embedded Coordinator.</p> Background <p>The fonts, logos, and image in the background reflect my personal desktop setup as seen through my transparent terminal.</p> <p>The first thing you'll see is the Logs window, which displays feedback from all background processes. You can adjust the output detail using the _log_level variable in the Ratslang file. Valid settings are <code>error</code>, <code>warn</code>, <code>info</code> (default), and <code>debug</code>.</p> <p>You can toggle the Logs window with ? or quit Minot with q. For all keybindings, see here.</p>"},{"location":"tui.html#bagfile-query","title":"Bagfile Query","text":"<p>At the bottom of the UI, you'll find the Compare indicator, which shows the current mode: Compare or Wind. Refer to the keybindings page for how to Switch Mode. From this point onward, specific key presses or actions won't be explicitly mentioned.</p> <p>With Wind mode activated, you can move the Wind Cursor in the bottom right corner using Vim-like motions. Consider this a selection of lines from the file specified when launching the binary from the terminal. You can also select multiple lines simultaneously using Select Mode. It will change to a [W], and you can use the same motions to expand the selection. By default, it selects all lines with <code>*</code>.</p> <p></p> <p>At this point, it should become obvious that you'll need the Ratsfile open at the same time since you have no feedback like contents of the file. The file can also be modified, but be sure to save changes before returning to the TUI. You can then evaluate the selected lines.</p> <p>Ratsfile evaluation is stateful. If you select a large variable definition part, the variable state will be cached by the TUI for all following evaluations. This allows you to subsequently select only the lines needed for execution, even if they depend on previous context.</p> <p>Warning</p> <p>The Wind Cursor is a simple file cursor and doesn't understand Ratslang's structure. Consequently, you could evaluate a variable definition within a namespace block, but if the namespace boundaries aren\u2019t included in the selection, the variable will be saved without the namespace.</p> <p>After evaluation, new log messages will appear (at least with _log_level = info), providing feedback on your commands.</p> <p>The screenshot shows an example for the logs while using the Bagfile Query feature (top) along with the Ratsfile code (bottom). The bottom right of the Minot TUI indicates that line 28 was successfully evaluated, playing <code>/ouster/imu</code> until a message was found from <code>/ouster/points</code>. The logs also show that an embedded Ratpub publisher was used to distribute the message over a network.</p>"},{"location":"tui.html#variable-sharing-log-and-compare","title":"Variable Sharing (LOG and Compare)","text":"<p>Most of the screen in Minot TUI is dedicated to matrix logging and comparison.  All matrices sent to LOG are displayed here.  You can review the history of received matrices or compare matrices from different Rats that share the same variable.</p> <p>You can move the cursor and observe the differences between each index of the right matrix (the comparison matrix) and a reference matrix on the left. You can swap the reference and comparison matrices and switch to different Rats with the same variable name.</p> <p>Comparisons account for a tolerance for fuzzy matching. The bottom left corner displays the current tolerance as a floating-point number.</p> <p>The final UI element is the lock indicator in the top left. Locking a variable causes the Rat to block the function until the TUI sends an unlock. This provides greater control over execution and enables advanced debugging. Combined with Bagfile Querying and variable triggers, you can create a step-by-step debugging experience by unlocking variables sequentially.</p> <p>By default, variables are not locked. You can overwrite this by setting <code>_start_locked = true</code> in your Ratsfile.</p> <p> Here is an example for the difference between floating matrices sent from two different Rats in the network. The tolerance is set to 0.9, and the right side shows the differences compared to the left.</p> <p>Red values indicate a lower value, with the absolute difference displayed inside the cell. Blue cells represent higher values than the reference, also with the absolute difference in the cell. The cursor is currently positioned on row 38, column 10.</p>"},{"location":"varshare.html","title":"Variable Sharing","text":"<p>When developing your node and choosing a tool to help you with it, you don't want to run through a huge setup or change your existing code a lot. The tool should adapt and move out of your way while still solving your problem.</p> <p>In this case, the problem is transparency. We want to know what happens in our systems at any point and see if our code does what we think it should do. That is the reason we write tests. For larger ROS networks, this becomes a lot more challenging.</p> <p>This is where librat comes in. It is a dependency free library to synchronise data between processes.</p> <p>Info</p> <p>We'll start with a Ratslang file. To learn more about Ratslang, read the Bagfile Query chapter.</p>"},{"location":"varshare.html#rule","title":"<code>rule!</code>","text":"<p>Define a strategy how a variable should be shared with a different Rat.</p> Definition<pre><code>rule! (&lt;Var&gt;\n  &lt;Rats&gt; &lt;Operator&gt; &lt;Rats&gt;\n  ...\n)\n</code></pre> Definition Primitives<pre><code>&lt;Rats&gt; := (String | LOG) [, &lt;Rats&gt;]\n&lt;Operator&gt; := -&gt; | &lt;- | == | =\n</code></pre> <p>Single Source Only</p> <p>Even though both sides of the operator can be an Array, the source side of it can never have more than one Rat. A line like <code>rat_a, rat_c -&gt; rat_b</code> is not valid. <code>rat_b -&gt; rat_a, rat_c</code> works and is interpreted as <code>rat_b</code> sending its variable to both <code>rat_a</code> and <code>rat_c</code>.</p> <p>Every variable inside a <code>rule!</code> block is expected to resolve to a connected Rat.</p> Example<pre><code>rule! (myvar\n\n  # Send myvar from rat1 to rat2, overwriting rat2\n  rat1 -&gt; rat2\n\n  # rat3 overwrite both variables of rat1 and rat2\n  rat1, rat2 &lt;- rat3\n\n  # Both rats send their myvar to the Minot TUI where they can be compared with each other\n  blue == yellow\n\n  # rat1 sends it myvar to the Minot TUI for displaying it\n  rat1 -&gt; LOG\n)\n</code></pre> <p>The <code>-&gt;</code> operator signalises sending the variable defined at the head from the left side of the operator to the right side. The data of the Rats on the right are overwritten. These operations are synchronised, meaning they wait for each other and block your thread.</p> <p>Sending from right to the left is signalised with <code>&lt;-</code> or <code>=</code>. These operators are redundant but they can make a difference in readability so we offer both options.</p> <p>You can also send everything to the Minot TUI to compare them with the <code>==</code> operator. This is just a shorter version of sending assigning each Rat to the hardcoded TUI name <code>LOG</code>. You can always add the <code>LOG</code> at any receiver list to also get the value inside the Comparison Window in Minot TUI.</p>"},{"location":"varshare.html#setup","title":"Setup","text":""},{"location":"varshare.html#standalone-coordinator","title":"Standalone Coordinator","text":"<p>Variable Sharing only needs the Coordinator, which can run standalone without the TUI. The binary takes a Ratslang file with Rules. It waits for every Rat in that Rule to be connected to the network before un(b)locking all Rats to continue their normal flow after intialisation.</p> Standalone Coordinator<pre><code>minot-coord ./rules.rl\n</code></pre>"},{"location":"varshare.html#minot-tui-with-embedded-coordinator","title":"Minot TUI with embedded Coordinator","text":"<p>When using the TUI with integrated Coordinator (the default when building Minot), the Rules should not be defined in the file you give to the TUI at startup. You need to set the <code>_rules</code> variable to a Path or String that is relative to the Ratslang file you are defining the variable in.</p> <p>This is basically a specialized include statement but it needs to be explicitely stated because there is a difference of where you define Rules.</p> debug.rl: Defining Rules when running with TUI<pre><code>_rules = ./my_rules.rl\n</code></pre> <p>You still can define Rules in the same file you write your Bagfile Query code. But the effect will be vastly different because Rules are also dynamic. You can delete all of them at runtime and add them again by evaluating lines within Minot TUI. You can read more about it here.</p> Why is that needed? Race Conditions <p>If you combine both, Bagfile Queries and Rule definitions into one file when running the TUI with Coordinator, it effectively activates a datarace.</p> <p>The Coordinator sees all needed Rats but then the TUI sends a command to delete them all because the TUI interprets the Rules as something new at runtime. In the meantime the Rats may already be connected but there is no guarantee.</p> <p>If a Rat asks the Coordinator what to do for a specific variable now, the coordinator does not have Rules for the Rat and tells it to continue. Then the Rule from the TUI comes in and the other Rat asks what to do at the same variable that the other Rat just skipped. The coordinator sees the new Rule and tells the Rat to wait or send its variable to the other one that already asked. Both Rats aren't synchronised anymore and deadlocks occur where both Rats wait for each other.</p>"},{"location":"varshare.html#library","title":"Library","text":"<p>The library for sharing variables is just called Rat. It is a Rust library with C bindings and built for minimal intrusion. See the installation guide for how to setup the technical side in your project.</p> <p>There are 3 functions.</p> CRust <pre><code>// Connect to a reachable Coordinator\nint rat_init(const char *node_name, int timeout_secs); // timeout &lt;= 0 blocks until connected\n\n// Read/Write a 2D column-major array\nint rat_bacon_f32(const char *variable_name, float *data, size_t rows, size_t cols);\n\n// All possible types for bacon in C:\n// u8  -&gt; char on ARM; unsigned char on non-ARM\n// f32 -&gt; float\n// f64 -&gt; double\n// i32 -&gt; int\n\n// Disconnect from the network\nint rat_deinit(); // optional\n</code></pre> <pre><code>use rat::*;\n\n// Connect to a reachable Coordinator\nfn init(\n  node_name: &amp;str,\n  timeout: Option&lt;std::time::Duration&gt;,\n  runtime: Option&lt;Arc&lt;tokio::runtime::Runtime&gt;&gt;,\n) -&gt; anyhow::Result&lt;()&gt;;\n\n\n// Read/Write any (De)Serializable Type\nfn bacon&lt;T&gt;(\n    variable_name: &amp;str,\n    data: &amp;mut T,\n    variable_type: VariableType,\n) -&gt; anyhow::Result&lt;()&gt;;\n\n// Disconnect from the network\nfn deinit() -&gt; anyhow::Result&lt;()&gt;;\n</code></pre> <p>VariableType Argument in <code>fn bacon</code></p> <p>This argument is currently needed for the C interop. So if you want to send a matrix to C or Mino TUI, the underlying datatype for the matrix must be specified. If you share variables with other Rusty Rats, you can set <code>VariableType::default()</code>.</p> <p>The example section on GitHub should give you enough code to use the library in your project without any more explanations.</p> <p>For a general description of data, the shared datatype in C is a 2D Matrix, which is also the only supported format for the Minot TUI Variable Viewer. If you want to share more abstract data than  1D Vectors or 2D Arrays, you'll need to encode the data yourself. Either into a different typed Matrix or into raw bytes (unsigned char on non-ARM). The <code>rows</code> argument is then <code>0</code> and <code>cols</code> is the length of your buffer.</p> <p>On the Rust side, there is a type called <code>NetArray</code> to assure C and TUI viewer compatibility. If you don't need that compatibility, you can also transport any type with automatic serialization by deriving <code>Serialize</code>, <code>Deserialize</code> and <code>Archive</code> from the powerful <code>rkyv</code> crate \u2013 just like in the next feature: Native Pub/Sub.</p>"}]}