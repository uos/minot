var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Introduction","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>Minot [mai\u00b7not] is a robot development toolset written in Rust and developed at the Computer Engineering Group at the Osnabr\u00fcck University. It provides tools for developing and verifying robot perception software.</p> <p>The main feature is the ability to see ROS 2 MCAP Bagfiles as queryable timeseries data. Minot uses its own simple language for configuration and querying.</p> <pre><code>minot tui &lt;yourquery.mt&gt;\n</code></pre> <p>Minot also runs as a ROS node. In that case, just prefix the usual ROS CLI:</p> <pre><code>ros2 run minot minot tui &lt;yourquery.mt&gt;\n</code></pre> <p>Refer to the installation for getting your Minot binaries.</p>"},{"location":"index.html#quickstart","title":"Quickstart","text":"<p>To get started quickly, we will do a very short Minot Hello World. Minot will be installed in your home directory but everything gets cleaned afterwards.</p> <p>We require a ROS 2 Jazzy or Humble installation for this because we want to see our point clouds in RViz.</p> ROS Example<pre><code>sudo apt install curl unzip\n\nmkdir minot-bagfile-demo &amp;&amp; cd minot-bagfile-demo\nsource /opt/ros/jazzy/setup.bash 2&gt;/dev/null || source /opt/ros/humble/setup.bash\n\n# Get Minot with ROS2 publisher\ncurl -sSLf https://uos.github.io/minot/install | sh -s -- --ros-distro $ROS_DISTRO\n\n# Get a Bagfile saved with mcap storage\ncurl -Lo dlg_cut.zip \"https://myshare.uni-osnabrueck.de/f/5faf4154af384854ab94?dl=1\" \\\n    &amp;&amp; unzip dlg_cut.zip \\\n    &amp;&amp; rm dlg_cut.zip\n\n# Get the query\ncurl -Lo demo.mt \"https://uos.github.io/minot/assets/demo_publish.mt\"\n\n# Get the rviz demo preset\ncurl -Lo demo.rviz \"https://uos.github.io/minot/assets/demo_publish.rviz\"\n\n# Run rviz and wait for data\nrviz2 -d demo.rviz\n</code></pre> <p>Open a new terminal.</p> Minot TUI<pre><code>source /opt/ros/$ROS_DISTRO/setup.bash\n\n# Run\nminot tui demo.mt\n\n# Press Space\n# You should see a 3D point cloud in rviz2 now.\n# Press j until you see \"W3\" in the bottom right.\n# Press Space again to evaluate line 3 of demo.mt and repeat how often you like.\n# Quit Minot with q\n\n# Clean up everything we created\ncd .. &amp;&amp; rm -rf minot-bagfile-demo &amp;&amp; minot-uninstall\n</code></pre> <p>All the provided features are meant to be used at development time to give you full control over the incoming data. It gives you transparency for complex systems where thousands of small sensor data packets are processed each second. With Minot, you regain control and explainability over what's happening when developing and integrating your Robot.</p> <p>Independence</p> <p>Minot is a collection of binaries and libraries. They can be used in your existing ROS1 or ROS2 nodes or completely separate from any system. This allows cross-ROS communication using its own networking layer without adding dependencies. With Minot, you can also write, test and debug ROS perception nodes without needing ROS on your system (currently Rust-only). This is especially useful for testing, where determinism is essential. When you are done, just comment out a few lines or change a compile flag and you are ready to run your node in ROS.</p> <p>There are 3 features. They can be used standalone but when combined, they enable superpowers.</p>"},{"location":"index.html#bagfile-querying","title":"Bagfile Querying","text":"<p>With ROS you can record and play everything published to the ROS network. This enables reproducability for nodes and greatly improves the safety of developing real robots. Bagfiles are great! But the ROS tooling for playing the Bagfile is limited. It's still enough for most use cases but there are times where you need complete control over the data that is published to your subscribers. Minot packages its own language for fine grained filtering and cursor control inside your Bagfile for fast iterations. This is called Bagfile Querying in Minot.</p> <p>For more information, visit the feature page.</p>"},{"location":"index.html#variable-sharing","title":"Variable Sharing","text":"<p>One of the main tasks of the ROS Pub/Sub system (excluding non-sensor pipelines with actions and service) is sharing a new value of something. At development time, when accuracy is at the highest priority, this async model might be in your way.</p> <p>With librat, you can share variables synchronously over the network. The library is written in Rust but targeted at C. It's built for the absolute minimal user footprint. You initialise it once and then give it any variables to cling to without changing anything else in your existing code. Just look at the header file. You then explain the routes to the Minot TUI with intuitive syntax.</p> <p>Variable sharing is a powerful building block and it can easily be used outside of the ROS context. Click here to learn more.</p> <p>From Comparing to full E2E Testing</p> <p>By just writing a \"proc1 == proc2\", and adding 4 lines of code in total, you can check the equality of a variable from two different processes (proc1, proc2) that don't need to share the language or system. Comparing is just syncing both variables with the TUI.</p> <p>This also effectively describes a unit test over the network. And together with using checkpoints as trigger for a Bagfile publish, Minot effectively gives you an entire E2E testing framework for ROS networks.</p>"},{"location":"index.html#quickstart_1","title":"Quickstart","text":"<p>We will need a modern Rust compiler for this example.</p> <p>Build and run the libraries and the Coordinator.</p> <pre><code>git clone https://github.com/uos/minot &amp;&amp; cd minot\ncargo build\n\n./target/debug/minot-coord mt/varshare_demo.mt\n</code></pre> <p>Start a second terminal to run <code>rat1</code> in Rust. </p><pre><code>cargo run --example rat1\n</code></pre><p></p> <p>Start a third terminal to build and run <code>rat2</code> in C.</p> <pre><code>gcc rat/examples/rat2.c -o rat2 -L./target/release -l:librat.a -lm -Wl,-z,noexecstack\n\n./rat2\n\n# rat1 and rat2 terminate successfully.\n# Look at the source code of the C file you just compiled.\n# rat1 just flipped the 0 from rat2 to 1.\n\n# Clean up\ncd .. &amp;&amp; rm -rf minot\n</code></pre> <p>Notably, this example does not even run the Minot binary but just a minimal subset for network communication.</p>"},{"location":"index.html#native-publishsubscribe","title":"Native Publish/Subscribe","text":"<p>The Pub/Sub model has proven itself among ROS developers. It's an intuitive way to exchange time series data. But sometimes adding the entire ROS stack with all its solutions for problems outside of the domain of the problem your node tries to solve just seems like overkill.</p> <p>For these cases, the native Rust library ratpub can help. By building on the same concepts as Variable Sharing, it removes ROS from the dependency tree at development time if you only use the pub/sub API from ROS. Read more about it here.</p>"},{"location":"index.html#quickstart_2","title":"Quickstart","text":"Pub/Sub without ROS<pre><code># Clone the example nodes\ngit clone https://github.com/stelzo/ratpub-demo &amp;&amp; cd ratpub-demo\n\n# Install the Coordinator\npip install minot-cli\n\n# Run it\nminot-coord\n</code></pre> <p>Start a second terminal to run the a node. </p><pre><code>cargo run --bin node1\n</code></pre><p></p> <p>Start a third terminal another one. </p><pre><code>cargo run --bin node2\n</code></pre><p></p> <p>Exit everything with Ctrl+C. Then cleanup everything we created: <code>cd .. &amp;&amp; rm -r ratpub-demo &amp;&amp; pip uninstall minot-cli -y</code>.</p> <p>Find out how this nodes works and how to write them here.</p> <p>Minot was developed out of frustration. Maybe you can feel the pain as well:</p> <p>The Pain</p> Message TimingIgnore NetworkingReproducability <p>Does your system behave different each time you play a Bagfile until you find out it actually works when playing it a little bit slower?</p> <p>Have you ever asked yourself why you should care about QoS settings, out-of-order message pipelines or the dependency of ROS2 itself when developing a Proof of Concept?</p> <p>Have you ever developed a ROS Node with state that unexpectedly changes for some reason and now you try to reproduce it?</p>"},{"location":"bagquery.html","title":"Bagfile Query","text":""},{"location":"bagquery.html#bagfile-query","title":"Bagfile Query","text":"<p>While developing ROS nodes, Bagfiles are essential for reproducability. With Minot you can query that recording and control each message that is published to your nodes. Bagfile Query is not built for a long stream of data. The idea is to grab specific chunks that fit some query and send them via the Coordinator (like a ROS1 Master) to all connected nodes that care about publishing Bagfile data. It is not meant to be a replacement for <code>ros2 bag play</code>. If you just want to play a Bagfile, we recommend the usual ROS tooling.</p> <p>To establish the power of querying, we will implement the typical <code>ros2 bag play</code> in Minot.</p> <p>To run the queries, you will need the Minot TUI binary. It expects a Ratslang file (<code>.rl</code>) as the first argument. When started, we typically are already in the Wind-Zen-Mode. It is the default view of the TUI but if you went wrong somewhere, you can get there again by switching modes until you get to Wind-Mode with w and then optionally go to Zen-Mode (or minimal Bagfile Querying Mode) to hide the Variable Sharing features with z. We now want to tell Minot which lines of the file to execute, so keep the file opened somehwere.</p> <p>The language of the file</p> <p>Minot uses an earlier, extended version of Ratslang, a minimal configuration language that inherently handles time and length units. The language is small, open source and easy. You should be able to read and speak it fluently by reading the 20 line example here.</p> <p>Outside of the typical configuration functionality of Ratslang, Minot defines functions specifically created for Bagfile Querying.</p>"},{"location":"bagquery.html#reset","title":"<code>reset!</code>","text":"<p>Load a Bagfile and set the cursor to the beginning.</p> <p>This function requires a path to a Bagfile (directory name). The path is relative to your current working directory where you started the Minot TUI.</p> Example<pre><code>reset! ./mybag\n</code></pre> Definition<pre><code>reset! &lt;Path&gt;\n</code></pre> <p>Warning</p> <p>At the moment, we only support the MCAP storage backend. It is the default for Rosbags since ROS2 Iron Irwini. For older Bagfiles, follow the conversion guide here.</p>"},{"location":"bagquery.html#pf","title":"<code>pf!</code>","text":"<p>Play frames (messages) from the currently loaded Bagfile. </p>Example<pre><code>_bag.{\n  lidar.{\n    _topic = \"/velodyne_points\"\n    _type = Cloud\n    _short = \"l\"\n  }\n  imu.{\n    _topic = \"/imu/data\"\n    _type = Imu\n    _short = \"i\"\n  }\n}\n\n# send all lidar frames between the time of 10s and 20s of the bagfile immediately\npf! l 10s..20s\n\n# send all lidar and imu frames between the time of 10s and 20s of the bagfile\n# when reaching var1\npf! [l, i] 10s..20s var1\n\n# send all lidar frames between the time of 10s and 20s of the bagfile\n# but slow down time so it sends it over 2 minutes\npf! l 10s..20s 2mins\n\n# send the next imu frames until 2 lidar frames are encountered\npf! i, l 2\n\n# send the next 10 lidar frames but spread them out over 20s\npf! l 10 20s\n\n# send the next 10 seconds of lidar frames everytime a rat reaches var1\npf! l 10s var1\n</code></pre><p></p> <p>When you need to select some lines over and over again, you can add named sections.  </p>Sections Example<pre><code>#--- setup\n_bag.{\n  imu.{\n    _topic = \"/imu/data\"\n    _type = Imu\n    _short = \"i\"\n  }\n}\n#---\n\n#--- load_bag\nreset! ./bag\n#---\n\n#--- pub\npf! i 10 20s\n#---\n</code></pre><p></p> <p>Now you can jump to sections with PageDown/PageUp in the Minot TUI.</p> <p>Formal Definition</p> Definition Normal<pre><code>pf! &lt;Topics&gt; &lt;Span&gt; [&lt;PlayingSpan&gt; [&lt;Trigger&gt;]] \n</code></pre> Definition Conditional<pre><code>pf! &lt;Topics&gt;, &lt;UntilTopics&gt; &lt;UntilCondition&gt; [&lt;PlayingSpan&gt; [&lt;Trigger&gt;]] \n</code></pre> <p>Conditional Queries are a special form of <code>&lt;Span&gt;</code> but they can fail with some combinations that make no sense in this context. There is only one important consideration when using Conditionals: the cursor stops before consuming the condition. So a query like <code>pf! x, y 1</code> will stop the cursor right before the <code>y</code> topic. You can consume it then with any other query since they are inclusive. Like a fxied number: <code>pf! y 1</code>.</p> Definition Primitives<pre><code>&lt;UntilTopics&gt; := &lt;Topics&gt;\n&lt;Topics&gt; := Array&lt;TopicIdentifier&gt; | &lt;TopicIdentifier&gt;\n\n&lt;PlayingSpan&gt; := &lt;RelativeSpan&gt; | &lt;Factor&gt;\n&lt;Factor&gt; := &lt;Float&gt;\n\n&lt;Span&gt; := &lt;AbsoluteSpan&gt; | &lt;RelativeSpan&gt;\n&lt;AbsoluteSpan&gt; := [&lt;Time&gt;]..[&lt;Time&gt;]\n&lt;RelativeSpan&gt; := &lt;Time&gt;\n\n&lt;Trigger&gt; := &lt;TriggerVariable&gt; [&lt;TriggerMode&gt;]\n&lt;TriggerVariable&gt; := &lt;String&gt;\n&lt;TriggerMode&gt; := d | f\n</code></pre> <p>The <code>&lt;TriggerMode&gt;</code> specifies dynamic dispatch with <code>d</code> and fixed with <code>f</code>. When not specified, dynamic is assumed. Dynamic dispatch means the Coordinator will ask the TUI to evaluate the query when reaching the variable. Fixed mode will evaluate the query first and publish the same messages everytime it reaches the variable.</p> <p><code>&lt;TriggerVariable&gt;</code> must correspondend to a variable set in the rules for sharing variables. Click here for more information. <code>&lt;TriggerVariable&gt;</code> is defined in the file by the user. There is an existing struct format Minot is looking for. It looks like this:</p> <p></p>Setting TopicIdentifier<pre><code>_bag.{\n\n  yourchosenname.{\n    _topic = &lt;Path&gt;\n    _short = &lt;String&gt;\n    _type = Cloud|Imu|Odom|Mixed|Any\n  }\n\n  yournexttopic.{\n    ...\n  }\n\n  ...\n}\n</code></pre> Every new namespace you define in <code>_bag</code> will be checked for <code>_topic</code>, <code>_short</code> and <code>_type</code>. You can interpret this as configuring an Array of Structs without having Structs in the language.<p></p> <p><code>yourchosenname</code> is a filler for any name you choose to call this TopicIdentifier. You can then use that name inside your <code>pf!</code> function.</p> <p>When debugging something with a lot of iterations, it is often convenient to abbreviate your names. With <code>_short</code> you can give your identifier an alternative name.</p> <p>The field <code>_type</code> is of special interest for Minot when querying. It matches the given type to the message at the current cursor position. <code>_type</code> currently can be one of Cloud, Imu or Any. They can easily be extended to more messages as needed in the source code. A type is necessary when you want to publish messages outside of ROS2 installations.</p> <ul> <li>Cloud == <code>sensor_msgs/msg/PointCloud2</code></li> <li>Imu == <code>sensor_msgs/msg/Imu</code></li> <li>Odom == <code>nav_msgs/msg/Odometry</code></li> <li>Mixed == Any of the above</li> </ul> <p>The Any type will match every message type - regardless of existing mappings. In the installation section, this behaviour is defined as with or without any-type. By specifying an exisiting type, Minot can use it outside of ROS2 land. For example in ROS1 or the Native Pub/Sub library.</p> <p>Specifying <code>_topic</code> allows for more detailed message matching. When you got multiple Imu topics in your Bagfile, this parameter becomes essential.</p> Multiple Types and QoS per Topic <p>ROS2 allows many publishers to the same topic with different types and QoS settings. Minot assumes a simple environment, where a topic is always published by one publisher with one QoS. While multiple publishers work with Minot, it itself only uses a single publisher with one QoS, which still works for common multi-publisher systems like TF.</p> <p>We now got everything to implement the <code>ros2 bag play</code> command within Minot as an example.</p> ros2 bag play ./bagfile<pre><code># Define our interests: match everything\n_bag.any._type = Any\n\n# Load the bagfile\nreset! ./bagfile\n\n# Play everything at original speed\npf! any .. 1.\n</code></pre> <p>Warning</p> <p>With this code, Minot will load the entire content of the Bagfile into memory first, which is probably not want you want. Also, you can not stop publishing mid-way through. This is why you should still use <code>ros2 bag play</code> for this use case \u2014 but it still beautifully demonstrates the flexibility of Minots query feature.</p> <p>For information on how to execute the code in Minot TUI, click here.</p>"},{"location":"installation.html","title":"Installation","text":"<p>Minot consists of libraries and binaries, some with different compile flags for many use cases.</p>"},{"location":"installation.html#ros-2","title":"ROS 2","text":""},{"location":"installation.html#binary-release","title":"Binary Release","text":"<p>We precompile the CLI with coordinator and ROS 2 publisher for our PPA. After the setup, you can simply run apt.</p> <pre><code># humble\nsudo apt install ros-humble-minot\n\n# jazzy\nsudo apt install ros-jazzy-minot\n</code></pre>"},{"location":"installation.html#from-source","title":"From Source","text":"<p>On Jazzy and Humble, you'll need to install a more modern Rust compiler first. The recommended script will automatically give you a newer version than 1.85, which is all we need.</p> <p>The Minot CLI integrates seamlessly with typical ROS tooling. Just clone the repository into the src folder of your ROS workspace.</p> <pre><code>cd ~/ros2_ws/src\ngit clone https://github.com/uos/minot\ncd ..\n\nrosdep install --from-paths src -y --ignore-src\n\ncolcon build --packages-select minot\nsource install/local_setup.bash\n</code></pre> <p>Building will take a while.</p> <p>Now run it like any ROS node.</p> <pre><code>ros2 run minot minot tui &lt;file.mt&gt;\n</code></pre> <p>Note that building from source will create huge incremental cache artifacts.</p>"},{"location":"installation.html#install-script","title":"Install Script","text":"<p>For most users, the easiest way to install everything Minot offers is using the installation script with a single command. This will install the <code>minot</code> binaries and libraries into your user directory.</p> <pre><code>curl -sSLf https://uos.github.io/minot/install | sh\n</code></pre> <p>For ROS support, make sure to have your ROS environment sourced before running the script.</p> <p>You can now run Minot.</p> <pre><code>minot --help\n</code></pre> <p>If the command could not be found, add your local binary folder to your <code>$PATH</code>: <code>echo 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.bashrc</code>.</p>"},{"location":"installation.html#using-cargo","title":"Using Cargo","text":"<p>Minot is on crates.io, so Rustaceans can just use Cargo as expected.</p> <p>This next line assumes ROS2 is installed and sourced.</p> <pre><code>cargo install minot --locked --features embed-ros2-c\n</code></pre> <p>The binary helper <code>cargo-binstall</code> is not supported because it does not support feature flags.</p>"},{"location":"installation.html#vs-code-extension","title":"VS Code Extension","text":"<p>Search for \"Minot\" in your editor an install the package. Running it will require a Minot binary in your <code>$PATH</code>. The extension will add syntax highlighting for <code>.mt</code> files and automatically activates as soon as you open a Minot file. You will see some buttons in the editor footer.</p> <p>Select some lines and run them with <code>Run Selection</code> or use the Command Palette Ctrl+Shift+P and type \"minot\" to also see their keybindings.</p>"},{"location":"installation.html#tree-sitter","title":"Tree-sitter","text":"<p>Minot comes with Tree-sitter syntax for highlighting outside of VS Code. See this repository for instructions on how to add Minot support to the Helix editor or use the repository for other editors that support Tree-sitter grammars.</p>"},{"location":"installation.html#advanced","title":"Advanced","text":"<p>You can also download and run the install script manually to investigate its effects before running it on your system.</p> <p>Use <code>--help</code> to see all available configurations of Minot.</p> <pre><code>wget https://uos.github.io/minot/install -o install.sh\nchmod +x install.sh\n./install.sh --help\n</code></pre> <p>The installation script will:</p> <ul> <li>Automatically detect your operating system and architecture</li> <li>Resolve to the newest compatible and stable version</li> <li>Download prebuilt binaries from GitHub releases if available</li> <li>Fall back to building from source using Rust if needed</li> <li>Copy binaries and libraries into your local user directory (customizable with <code>--dir</code>)</li> <li>Add the uninstall script (<code>minot-uninstall</code>) to the same directory for easy removal later</li> </ul> <p>Embedded Components:</p> <p>Use the <code>--ros-distro</code> option to specify which ROS2 publisher bindings to embed when building from source:</p> <ul> <li><code>jazzy</code> - ROS2 publisher (C API, needs sourced ROS2)</li> <li><code>humble</code> - ROS2 publisher (C API, needs sourced ROS2)</li> </ul> <p>Use the <code>--embed</code> option to specify which components to embed when building from source:</p> <ul> <li><code>coord</code> - Coordinator (default)</li> <li><code>ratpub</code> - Ratpub publisher</li> <li><code>ros1-native</code> - ROS1 publisher (native, no system dependencies)</li> <li><code>ros2-native</code> - ROS2 publisher with RustDDS (native, no system dependencies)</li> </ul> <p>Common usage examples:</p> <pre><code># Install with ROS2 Jazzy support\n./install.sh --ros-distro jazzy\n\n# Build with multiple components\n./install.sh --build --embed ros1 --ros-distro jazzy\n\n# Non-interactive mode (useful for CI/CD)\n./install.sh --yes --build --embed ratpub\n</code></pre>"},{"location":"installation.html#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>Binaries for common system configurations are available here.</p> <p>The <code>minot-$ROS_DISTRO-*</code> archives will only give you ROS specific binaries:</p> <ul> <li><code>minot</code> TUI + Coordinator + ROS2 Publisher (with any-type)</li> <li><code>wind-ros2-c</code> Standalone ROS2 Publisher (with any-type)</li> </ul> <p>Archives not specific to a ROS distribution contain builds that can be used independently.</p> <ul> <li><code>minot</code> TUI + Coordinator</li> <li><code>minot-coord</code> Standalone Coordinator</li> <li><code>librat.*, rat.h</code> C libraries for Variable Sharing</li> <li><code>wind-ros*-native</code> ROS Publisher using roslibrust for ROS1 and ros2-client for ROS2</li> </ul> <p>While the prebuilt binaries cover many common use cases, you may need to build Minot from source to tailor it to your specific needs. Building from source requires the Rust toolchain to be installed on your system.</p>"},{"location":"installation.html#all-in-one-binary","title":"All-in-one Binary","text":"<p>To build the Minot bundled binary, there are some feature flags for embedding common network participants for convenience. A detailed list of supported flags can be found in the Minot features definition.</p> <p>With default settings, Minot builds with an integrated coordinator. When running the following command with no changes, you will get a <code>minot</code> binary with integrated Coordinator and a <code>minot-coord</code> binary, that is just a Coordinator. The standalone Coordinator is enough for sharing variables with the rat library.</p> Publishing custom and any-type messages <p>Publishing any-type messages from a Bagfile (like <code>ros2 bag play</code>) needs the ROS2 C implementation to be linked to the message. When building the Rust bindings, it will link with every message in your <code>$PATH</code>. So if you use custom messages, you want to build Minot after you sourced your new message.</p> <p>To help you get up and running quickly, here are some popular configurations.</p> (Recommended) With ROS2 publisher (+ any-type, needs sourced ROS2)<pre><code>cargo install minot --locked --features embed-ros2-c\n</code></pre> <p>This next version does not need any ROS1 or ROS2 installation to compile. It tries to find other standalone Minot nodes in the network and publishes to them if you query a Bagfile:</p> Minimal with embedded Coordinator<pre><code>cargo install minot --locked\n</code></pre> <p>Or maybe you want to publish to ROS1 and ROS2 at the same time without needing a ROS installation. Since the input is always a ROS2 Bagfile, only mapped types can be published (no any-type).</p> With ROS1 and ROS2 publishers<pre><code>cargo install minot --locked --features embed-ros1-native,embed-ros2-native\n</code></pre>"},{"location":"installation.html#coordinator","title":"Coordinator","text":"<p>Running <code>cargo install</code> as shown above will also build a standalone variant of the Coordinator. It is called <code>minot-coord</code> in your path.</p> <p>Alternatively, a non-ROS Minot version is built for PyPI, which also bundles the Coordinator. Install the binary with pip.</p> <pre><code>pip install minot-cli\n</code></pre> <p>Then just run it.</p> <pre><code>minot-coord\n</code></pre>"},{"location":"installation.html#bagfile-publishers","title":"Bagfile Publishers","text":"<p>Tip</p> <p>You can compile the embedded publishers standalone and distribute them in your network.</p> <p>For example: you could run the TUI on a Mac, connected to a Robot with a Raspberry Pi over Wi-Fi or LAN, which runs ROS1 or ROS2 and the wind nodes.</p> <p>Standalone publishers live inside the <code>wind</code> module. You can compile/install them to your <code>$PATH</code> by changing the previous command from <code>minot</code> to <code>wind</code>.</p> <p>With <code>--all-features</code>, you'll get all binaries but you need to have ROS2 sourced.</p> Standalone Publishers (needs sourced ROS2)<pre><code>cargo install mt_wind --locked --all-features\n</code></pre> <p>The following flavours are available for publishing bagfile messages when specifying the respective feature:</p> <ul> <li>wind-ros2-c (with any-type) <code>--feature ros2-c</code></li> <li>wind-ros1-native <code>--feature ros1-native</code></li> <li>wind-ros2-native <code>--feature ros2-native</code></li> <li>wind-rat <code>--feature ratpub</code></li> </ul> <p>Only the C version requires a ROS2 installation at compile time.</p>"},{"location":"installation.html#rats","title":"Rats","text":"<p>Nodes in the Minot network that share data are called Rats (here is why). The functionality is shipped as a Rust and C library.</p>"},{"location":"installation.html#ubuntu","title":"Ubuntu","text":"<p>Our PPA provides <code>.deb</code> files for a system-wide installation. After the setup, you can simply run apt.</p> <pre><code>sudo apt install librat-dev\n</code></pre>"},{"location":"installation.html#debian-based-distros","title":"Debian-based Distros","text":"<p>The PPA mentioned above is specific to Ubuntu the package itself does not require any system dependencies. Therefore it can be installed manually on all debian-based distros.</p> Manual .deb Installation<pre><code>curl -s https://api.github.com/repos/uos/minot/releases/latest \\\n| grep \"browser_download_url\" \\\n| grep \".deb\" \\\n| grep \"$(dpkg --print-architecture)\" \\\n| cut -d '\"' -f 4 \\\n| xargs curl -L -O\n\nsudo dpkg -i ./librat-dev_*.deb\n</code></pre> <p>The package also installs a pkg-config file, which allows the following usage in CMake.</p> Example CMake<pre><code>find_package(PkgConfig REQUIRED)\npkg_check_modules(RAT REQUIRED librat)\n\nadd_executable(my_app main.c)\ntarget_include_directories(my_app PRIVATE ${RAT_INCLUDE_DIRS})\ntarget_link_libraries(myfind_package(PkgConfig REQUIRED)\npkg_check_modules(RAT REQUIRED librat)\n\nadd_executable(my_app main.c)\ntarget_include_directories(my_app PRIVATE ${RAT_INCLUDE_DIRS})\ntarget_link_libraries(my_app PRIVATE ${RAT_LIBRARIES})\n</code></pre>"},{"location":"installation.html#from-source_1","title":"From Source","text":"<p>Building from source generates a static and shared library in the <code>./target/release/</code> folder. You will need to clone the repository first.</p> Build librat from source<pre><code>git clone https://github.com/uos/minot\ncd minot\ncargo build --package mt_rat --release\n</code></pre> <p>A typical system-wide installation is done by copying the libraries to your linker path. Alternatively, you may change the link path and include search paths in your build system.</p> <pre><code>sudo cp ./target/release/librat.* /usr/local/lib/\nsudo mkdir -p /usr/local/include/rat/\nsudo cp ./rat/rat.h /usr/local/include/rat/\n</code></pre> <p>Then you can use the library in your C/C++ code. </p><pre><code>#include &lt;rat/rat.h&gt;\n</code></pre><p></p> <p>And link with <code>-lrat</code>.</p> <p>For using the Rust library, just add this to your dependencies in <code>Cargo.toml</code>.</p> Cargo.toml<pre><code>[dependencies]\nmt_rat = \"0.4.2\"\n</code></pre>"},{"location":"installation.html#ratpub","title":"Ratpub","text":"<p>Ratpub is only available for Rust. It uses Tokio for async I/O. For using the library in your project, add these lines to your dependencies in <code>Cargo.toml</code>.</p> Cargo.toml<pre><code>[dependencies]\nratpub = \"0.4.2\"\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre> <p>Since you probably want to use existing ROS 2 message definitions, you can also add the following crate, which is auto-generated from the Jazzy release. It bundles all usual types and implements the required <code>rkyv</code> traits for sending them over the Minot network.</p> Cargo.toml<pre><code>[dependencies]\nros2-interfaces-jazzy-rkyv = { version = \"0.0.5\", features = [\n  \"std_msgs\", # add more here\n] }\n</code></pre> <p>Learn more on how to use it in your Code by visiting the feature page.</p>"},{"location":"installation.html#uninstall","title":"Uninstall","text":"<p>If you want to remove every file installed from the install script, you can run <code>minot-uninstall</code>. This executes a generated shell script that saved all added files and now removes them (including itself). You can also run <code>minot uninstall</code> to uninstall minot and minot-coord. Or <code>cargo uninstall minot</code> if you installed binaries with cargo. The debian packages can be uninstalled with <code>sudo apt remove librat-dev ros-jazzy-minot</code> etc.</p>"},{"location":"keybindings.html","title":"Keybindings","text":""},{"location":"keybindings.html#keybindings","title":"Keybindings","text":"<p>Keybindings for the Minot TUI. They cannot be changed after compile time for the moment.</p>"},{"location":"keybindings.html#basics","title":"Basics","text":"Command Key Quit q, Esc, Ctrl+c Toggle Log Window ? Switch Mode (Wind/Compare) w"},{"location":"keybindings.html#wind-cursor","title":"Wind Cursor","text":"Command Key Toggle Zen Mode (in wind mode) z Move Cursor up k, \u2191 Move Cursor down j, \u2193 Select next label PageDown Select previous label PageUp Toggle Goto Line Window (in wind mode) g Apply Goto Line Input Enter Select All Lines * Toggle Select Mode (in wind mode) v Compile and Run Selection (in wind mode) Space"},{"location":"keybindings.html#rules","title":"Rules","text":"Command Key Clear (in compare mode) Space <p>Adding new ones happens automatically when firing the <code>.mt</code> file if it contains some.</p>"},{"location":"keybindings.html#matrix-compare-window","title":"Matrix Compare Window","text":"Command Key Move Cursor Left (in compare mode) h, \u2190 Move Cursor Up (in compare mode) k, \u2191 Move Cursor Down (in compare mode) j, \u2193 Move Cursor Right (in compare mode) l, \u2192 Toggle Cursor Popup (in compare mode) g Apply Current Input in Popup Enter Scroll History Older Shift+Tab Scroll History Newer Tab Swap Compare Buffers Shift+f Move Through Rats at Current Var Ctrl+PageUp / Ctrl+PageDown Unlock Vars . Lock Next Var - Unlock Until Next Var (Step forward) , Increase Left Window Column Width Ctrl+q Decrease Left Window Column Width Ctrl+a Increase Right Window Column Width Ctrl+w Decrease Right Window Column Width Ctrl+s"},{"location":"keybindings.html#difference-tolerance","title":"Difference Tolerance","text":"Command Key Increase at Current Cursor Shift+t Decrease at Current Cursor t Move Cursor Left p Move Cursor Right Shift+p"},{"location":"lore.html","title":"Lore","text":"<p>You might wonder about the unusual names used in Minot.</p> <p>The simple answer is greppability. Minot is designed for use during development. As it's an external system, I made a few assumptions:</p> <p>You'll likely want to remove Minot before releasing your software. You'll also need to quickly locate Minot calls. Since words like bacon or rat are probably uncommon in your production code, Minot can use them without conflict. This makes them easy to find with a project-wide text search.</p> <p>However, there's a more interesting story behind the names.</p> <p></p> <p>Minot is named after Minot's Ledge Lighthouse near Boston (see Wikipedia). Early versions of the lighthouse didn't last, so a new one was built with a solid granite base. This formidable structure, standing alone at the edge of shallows, was a statement of permanence. Completed in 1860, it still stands today.</p> <p>Info</p> <p>There are local stories and songs about this lighthouse, which I recommend for unwinding after a long day of working with robot algorithms. The image on the right is from a storm in 1978, photographed by Kevin Cole.</p> <p>The lighthouse symbolises coordination at sea\u2014a beacon of hope and safety amid chaos. In contrast to this stability, there are ships navigating rough seas, battling strong winds. Wind is a metaphor for Bagfile data that propels the Ships (our Nodes). The Wind is generated by Turbines (the bagfile publisher nodes). The internal networking library is called Sea, which is self-explanatory.</p> <p>Every Ship (Node) has Rats on board because, during development, a Ship isn't production-ready and still has issues. Rats love Bacon (variables), and when they find Bacon they want to tell their friends and share. So, they use a Cannon on your ship to shoot and retrieve Bacon from one ship to another\u2014across the Sea (network). The Coordinator (lighthouse) oversees everything. While many of these names don't appear in the user-facing API, you'll find these concepts throughout the source code.</p> <p>This story should also make the name of the configuration language, Ratslang, self-explanatory.</p> <p>I like the idea of installing Rats on your Ship to help you stabilize its voyage. Rats do the dirty work by just liking Bacon and being proud of finding it. And once everything is working, you simply remove the Rats again, and your Ship is like new. But now its ready to sail with much more stability.</p>"},{"location":"pubsub.html","title":"Native Pub/Sub","text":""},{"location":"pubsub.html#native-pubsub","title":"Native Pub/Sub","text":"<p>An async implementation of a basic Publish/Subscribe pattern with a ROS-like API.</p> <p>Currently not compatible with C</p> <p>The library for Native Publish/Subscribe is currently only available in Rust because of decisions made for minimal overhead in serialisation/deserialisation. It also not planned to support C or C++ any time soon.</p> <p>While Bagfile Query and Variable Sharing are the main features of Minot, this library is just a small cherry on top. The <code>ratpub</code> library uses existing networking primitives from Variable Sharing like Rats and dynamic Rules and implements a minimal Publish/Subscribe pattern on top of it.</p> <p>When used in static and simple environments (no lifecycle node, assuming stable network and more), it is stable enough for replacing the ROS2 Publish/Subscribe API. But it is absolutely not on par with ROS features.</p> <p>Domain ID for Network Isolation</p> <p>To avoid network collisions when multiple independent Minot instances run on the same network, you can use the <code>MINOT_DOMAIN_ID</code> environment variable. This is similar to ROS2's <code>ROS_DOMAIN_ID</code> concept.</p>"},{"location":"pubsub.html#coordinator","title":"Coordinator","text":"<p>Like in ROS1, the communication needs a Master. In this case it is our Coordinator, which we can run without any arguments.</p> <p>Since we do not rely on ROS here, we can simply use the pip version of Minot, which is built with Ratpub and already ships with with the coordinator.</p> <pre><code>pip install minot-cli\n</code></pre> <p>Start the Coordinator in your terminal.</p> <pre><code>minot-coord\n</code></pre> <p>Info</p> <p>The example uses pre-generated messages that ship with ROS2 Jazzy to already give you the types you typically use in your Node. If that is not enough, you can add your own types that implement <code>Serialize</code>, <code>Deserialize</code> and <code>Archive</code> from <code>rkyv</code>.</p> <p>After adding the library to your Cargo.toml, you can create a publisher and a subscriber.</p> publisher.rs<pre><code>use ratpub::Node;\nuse ros2_interfaces_jazzy_rkyv::std_msgs::msg;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // env_logger::init(); // some useful output when running: RUST_LOG=info cargo run \n\n    // Resolves when connected to the Coordinator\n    let node = Node::create(\"my_node_pub\".to_owned()).await?;     \n\n    let pubber = node\n        .create_publisher::&lt;msg::String&gt;(\"/some_topic\".to_owned())\n        .await?;\n\n    let msg = msg::String {\n        data: \"Hello World \ud83d\udd96\".to_owned(),\n    };\n\n    loop {\n        pubber.publish(&amp;msg).await?;\n        sleep(Duration::from_secs(1)).await;\n    }\n}\n</code></pre> <p>Info</p> <p>Nodes will automatically detect the Coordinator and do not need any setup. Like the other networking stack from Minot, you just need to ensure that each Node that you want to connect with each other is reachable in the network.</p> <p>In contrast to Variable Sharing, the publisher does not care about syncing with the subscriber. But like most abstractions, this comes at a cost. Here it is setting the capacity of the queue length for the subscriber - like in ROS.</p> subscriber.rs<pre><code>use ratpub::Node;\nuse ros2_interfaces_jazzy_rkyv::std_msgs::msg;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // env_logger::init();\n\n    let node = Node::create(\"my_node_sub\".to_owned()).await?;\n\n    let mut subber = node\n        .create_subscriber::&lt;msg::String&gt;(\"/some_topic\".to_owned(), 10)\n        .await?;\n\n    while let Some(msg) = subber.next().await {\n        println!(\"Received Message: {}\", &amp;msg.data);\n    }\n\n\n    Ok(())\n}\n</code></pre> <p>Mind that we don't need to <code>spin_once</code> here thanks to async like in other Rust ROS libraries.</p> <p>Unstable Networks</p> <p>In the current state, <code>ratpub</code> should only be used in stable networks. There are still use cases that break your expectations. These problems are planned to get fixed though.</p> <p>Examples</p> <ul> <li>If a publisher dies or disconnects in an existing Pub/Sub connection the subscriber will never get messages on this topic again, even when the publisher comes back or other ones still publish on that topic.</li> <li>Loosing connections to the Coordinator at runtime will result in an error. <code>ratpub</code> is therefore not really reliable in unrealiable networks like Wi-Fi.</li> <li>Nodes are always talking to the Coordinator, which is a good feature for reconfigurable topics but also adds latency. The plan is to add static and dynamic topics, where both have the same features but both have better latency for their respective use case.</li> </ul> <p>Now just run your publisher, the subscriber and the Coordinator at the same time and observe the logs.</p>"},{"location":"tui.html","title":"Terminal","text":"<p>TUI stands for Terminal User Interface. In Minot, it functions as a dashboard with commands for controlling the features. It's the primary way you interact with Minot.</p> <p>After installing the binary with your chosen embeddings, you can run the TUI with: </p><pre><code>minot tui &lt;Path&gt;\n</code></pre><p></p> <p>The Path defines the configuration file for Bagfile Querying and Variable Sharing.</p> <p>On startup, Minot searches for a Coordinator and will immediately find it, since it starts one itself. The following interface will appear.</p> <p></p> <p>The freshly opened TUI with embedded Coordinator.</p> Background <p>The fonts, logos, and image in the background reflect my personal desktop setup as seen through my transparent terminal.</p> <p>The first thing you'll see is the Logs window, which displays feedback from all background processes. You can adjust the output detail using the _log_level variable in the Ratslang file. Valid settings are <code>error</code>, <code>warn</code>, <code>info</code> (default), and <code>debug</code>.</p> <p>You can toggle the Logs window with ? or quit Minot with q. For all keybindings, see here.</p>"},{"location":"tui.html#bagfile-query","title":"Bagfile Query","text":"<p>At the bottom of the UI, you'll find the Compare indicator, which shows the current mode: Compare or Wind. Refer to the keybindings page for how to Switch Mode. From this point onward, specific key presses or actions won't be explicitly mentioned.</p> <p>With Wind mode activated, you can move the Wind Cursor in the bottom right corner using Vim-like motions. Consider this a selection of lines from the file specified when launching the binary from the terminal. You can also select multiple lines simultaneously using Select Mode. It will change to a [W], and you can use the same motions to expand the selection. By default, it selects all lines with <code>*</code>.</p> <p></p> <p>At this point, it should become obvious that you'll need the Ratsfile open at the same time since you have no feedback like contents of the file. The file can also be modified, but be sure to save changes before returning to the TUI. You can then evaluate the selected lines.</p> <p>Ratsfile evaluation is stateful. If you select a large variable definition part, the variable state will be cached by the TUI for all following evaluations. This allows you to subsequently select only the lines needed for execution, even if they depend on previous context.</p> <p>Warning</p> <p>The Wind Cursor is a simple file cursor and doesn't understand Ratslang's structure. Consequently, you could evaluate a variable definition within a namespace block, but if the namespace boundaries aren\u2019t included in the selection, the variable will be saved without the namespace.</p> <p>After evaluation, new log messages will appear (at least with _log_level = info), providing feedback on your commands.</p> <p>The screenshot shows an example for the logs while using the Bagfile Query feature (top) along with the Ratsfile code (bottom). The bottom right of the Minot TUI indicates that line 28 was successfully evaluated, playing <code>/ouster/imu</code> until a message was found from <code>/ouster/points</code>. The logs also show that an embedded Ratpub publisher was used to distribute the message over a network.</p>"},{"location":"tui.html#variable-sharing-log-and-compare","title":"Variable Sharing (LOG and Compare)","text":"<p>Most of the screen in Minot TUI is dedicated to matrix logging and comparison.  All matrices sent to LOG are displayed here.  You can review the history of received matrices or compare matrices from different Rats that share the same variable.</p> <p>You can move the cursor and observe the differences between each index of the right matrix (the comparison matrix) and a reference matrix on the left. You can swap the reference and comparison matrices and switch to different Rats with the same variable name.</p> <p>Comparisons account for a tolerance for fuzzy matching. The bottom left corner displays the current tolerance as a floating-point number.</p> <p>The final UI element is the lock indicator in the top left. Locking a variable causes the Rat to block the function until the TUI sends an unlock. This provides greater control over execution and enables advanced debugging. Combined with Bagfile Querying and variable triggers, you can create a step-by-step debugging experience by unlocking variables sequentially.</p> <p>By default, variables are not locked. You can overwrite this by setting <code>_start_locked = true</code> in your Ratsfile.</p> <p> Here is an example for the difference between floating matrices sent from two different Rats in the network. The tolerance is set to 0.9, and the right side shows the differences compared to the left.</p> <p>Red values indicate a lower value, with the absolute difference displayed inside the cell. Blue cells represent higher values than the reference, also with the absolute difference in the cell. The cursor is currently positioned on row 38, column 10.</p>"},{"location":"varshare.html","title":"Variable Sharing","text":""},{"location":"varshare.html#variable-sharing","title":"Variable Sharing","text":"<p>When developing your node and choosing a tool to help you with it, you don't want to run through a huge setup or change your existing code a lot. The tool should adapt and move out of your way while still solving your problem.</p> <p>In this case, the problem is transparency. We want to know what happens in our systems at any point and see if our code does what we think it should do. That is the reason we write tests. For larger ROS networks, this becomes a lot more challenging.</p> <p>This is where librat comes in. It is a dependency free library to synchronise data between processes.</p> <p>We'll start with a descriptive file. To learn more about the used language, read the Bagfile Query chapter.</p>"},{"location":"varshare.html#rule","title":"<code>rule!</code>","text":"<p>Define a strategy how a variable should be shared with a different Rat.</p> Example<pre><code>rule! (myvar\n\n  # Send myvar from rat1 to rat2, overwriting rat2\n  rat1 -&gt; rat2\n\n  # rat3 overwrite both variables of rat1 and rat2\n  rat1, rat2 &lt;- rat3\n\n  # Both rats send their myvar to the Minot TUI where they can be compared with each other\n  blue == yellow\n\n  # rat1 sends it myvar to the Minot TUI for displaying it\n  rat1 -&gt; LOG\n)\n</code></pre> <p>Formal Definition</p> Definition<pre><code>rule! (&lt;Var&gt;\n  &lt;Rats&gt; &lt;Operator&gt; &lt;Rats&gt;\n  ...\n)\n</code></pre> Definition Primitives<pre><code>&lt;Rats&gt; := (String | LOG) [, &lt;Rats&gt;]\n&lt;Operator&gt; := -&gt; | &lt;- | == | =\n</code></pre> <p>Even though both sides of the operator can be an Array, the source side of it can never have more than one Rat. A line like <code>rat_a, rat_c -&gt; rat_b</code> is not valid. <code>rat_b -&gt; rat_a, rat_c</code> works and is interpreted as <code>rat_b</code> sending its variable to both <code>rat_a</code> and <code>rat_c</code>.</p> <p>Every variable inside a <code>rule!</code> block is expected to resolve to a connected Rat.</p> <p>The <code>-&gt;</code> operator signalises sending the variable defined at the head from the left side of the operator to the right side. The data of the Rats on the right are overwritten. These operations are synchronised, meaning they wait for each other and block your thread.</p> <p>Sending from right to the left is signalised with <code>&lt;-</code> or <code>=</code>. These operators are redundant but they can make a difference in readability so we offer both options.</p> <p>You can also send everything to the Minot TUI to compare them with the <code>==</code> operator. This is just a shorter version of sending assigning each Rat to the hardcoded TUI name <code>LOG</code>. You can always add the <code>LOG</code> at any receiver list to also get the value inside the Comparison Window in Minot TUI.</p>"},{"location":"varshare.html#setup","title":"Setup","text":""},{"location":"varshare.html#standalone-coordinator","title":"Standalone Coordinator","text":"<p>Variable Sharing only needs the Coordinator, which can run standalone without the TUI. The binary takes a Ratslang file with Rules. It waits for every Rat in that Rule to be connected to the network before un(b)locking all Rats to continue their normal flow after intialisation.</p> Standalone Coordinator<pre><code>minot-coord ./rules.mt\n</code></pre>"},{"location":"varshare.html#minot-tui-with-embedded-coordinator","title":"Minot TUI with embedded Coordinator","text":"<p>When using the TUI with integrated Coordinator (the default when building Minot), the Rules should not be defined in the file you give to the TUI at startup. You need to set the <code>_rules</code> variable to a Path or String that is relative to the Ratslang file you are defining the variable in.</p> <p>This is basically a specialized include statement but it needs to be explicitely stated because there is a difference of where you define Rules.</p> Defining Rules when running with TUI<pre><code>_rules = ./my_rules.mt\n</code></pre> <p>You still can define Rules in the same file you write your Bagfile Query code. But the effect will be vastly different because Rules are also dynamic. You can delete all of them at runtime and add them again by evaluating lines within Minot TUI. You can read more about it here.</p> Why is that needed? Race Conditions <p>If you combine both, Bagfile Queries and Rule definitions into one file when running the TUI with Coordinator, it effectively activates a datarace.</p> <p>The Coordinator sees all needed Rats but then the TUI sends a command to delete them all because the TUI interprets the Rules as something new at runtime. In the meantime the Rats may already be connected but there is no guarantee.</p> <p>If a Rat asks the Coordinator what to do for a specific variable now, the coordinator does not have Rules for the Rat and tells it to continue. Then the Rule from the TUI comes in and the other Rat asks what to do at the same variable that the other Rat just skipped. The coordinator sees the new Rule and tells the Rat to wait or send its variable to the other one that already asked. Both Rats aren't synchronised anymore and deadlocks occur where both Rats wait for each other.</p>"},{"location":"varshare.html#library","title":"Library","text":"<p>The library for sharing variables is just called Rat. It is a Rust library with C bindings and built for minimal intrusion. See the installation guide for how to setup the technical side in your project.</p> <p>There are 3 functions.</p> CRust <pre><code>// Connect to a reachable Coordinator\nint rat_init(const char *node_name, int timeout_secs); // timeout &lt;= 0 blocks until connected\n\n// Read/Write a 2D column-major array\nint rat_bacon_f32(const char *variable_name, float *data, size_t rows, size_t cols);\n\n// All possible types for bacon in C:\n// u8  -&gt; char on ARM; unsigned char on non-ARM\n// f32 -&gt; float\n// f64 -&gt; double\n// i32 -&gt; int\n\n// Disconnect from the network\nint rat_deinit(); // optional\n</code></pre> <pre><code>use rat::*;\n\n// Connect to a reachable Coordinator\nfn init(\n  node_name: &amp;str,\n  timeout: Option&lt;std::time::Duration&gt;,\n  runtime: Option&lt;Arc&lt;tokio::runtime::Runtime&gt;&gt;,\n) -&gt; anyhow::Result&lt;()&gt;;\n\n\n// Read/Write any (De)Serializable Type\nfn bacon&lt;T&gt;(\n    variable_name: &amp;str,\n    data: &amp;mut T,\n    variable_type: VariableType,\n) -&gt; anyhow::Result&lt;()&gt;;\n\n// Disconnect from the network\nfn deinit() -&gt; anyhow::Result&lt;()&gt;;\n</code></pre> <p>VariableType Argument in <code>fn bacon</code></p> <p>This argument is currently needed for the C interop. So if you want to send a matrix to C or Mino TUI, the underlying datatype for the matrix must be specified. If you share variables with other Rusty Rats, you can set <code>VariableType::default()</code>.</p> <p>The example section on GitHub should give you enough code to use the library in your project without any more explanations.</p> <p>For a general description of data, the shared datatype in C is a 2D Matrix, which is also the only supported format for the Minot TUI Variable Viewer. If you want to share more abstract data than  1D Vectors or 2D Arrays, you'll need to encode the data yourself. Either into a different typed Matrix or into raw bytes (unsigned char on non-ARM). The <code>rows</code> argument is then <code>0</code> and <code>cols</code> is the length of your buffer.</p> <p>On the Rust side, there is a type called <code>NetArray</code> to assure C and TUI viewer compatibility. If you don't need that compatibility, you can also transport any type with automatic serialization by deriving <code>Serialize</code>, <code>Deserialize</code> and <code>Archive</code> from the powerful <code>rkyv</code> crate \u2013 just like in the next feature: Native Pub/Sub.</p>"}]}