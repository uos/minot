use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::str::FromStr;

use log::{debug, error, info, warn};
use sea::coordinator::COMPARE_NODE_NAME;
// use ros_pointcloud2::{points::PointXYZ, PointCloud2Msg};
use sea::{
    coordinator::CoordinatorImpl,
    net::PacketKind,
    // ImuMsg,
};

struct Wind {
    pub name: String,
}

struct Network {
    winds: Vec<Wind>,
}

impl Network {
    fn new() -> Self {
        Network { winds: Vec::new() }
    }
}

// #[derive(Debug, Copy, Clone)]
// enum BagReaderTask {
//     LidarFrame(u32),
//     OdomFrame(u32),
//     MixedWhile(f64), // Time in seconds
//                      // More here like "mixed until n lidar" or "random out of sync" etc
// }

// All possible variables that should be acted on must be known beforehand.
// They get an ID or get generated into a type? TODO
// ID => VariableRule
// hashmap[string] => ID
// ID => VariableRule

use rlc::ActionPlan;
use sea::Coordinator;

#[derive(Debug)]
enum LighthouseTask {
    // TODO variables currently handled manually because of a async deadlock
    // GetVariableChannel {
    //     ship: String,
    //     answer: oneshot::Sender<broadcast::Receiver<String>>,
    // },
    SendWind {
        ship_name: String,
        data: sea::WindData,
    },
    SendRatAction {
        ship_name: String,
        data: ActionPlan,
    },
    AppendRule {
        variable: String,
        commands: Vec<rlc::VariableHuman>,
    },
    RulesClear,
    LockNext,
    Unlock,
}

#[tokio::main(flavor = "multi_thread")]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let rules_file = PathBuf::from_str("./rules.rats")?;
    let rules = rlc::evaluate_rules_file(&rules_file)?;

    let mut clients = HashSet::new();
    for (_, inner_clients) in rules.raw().iter() {
        inner_clients.iter().for_each(|client| {
            clients.insert(client.ship.clone());
        });
    }

    // TODO On exit: disconnect all members of the network.
    // only use the rats that are mentioned. filter out the rest.
    // Winds are not mapped to rats, so they won't be filtered.

    let rules = std::sync::Arc::new(std::sync::RwLock::new(rules));
    let rules_changer = std::sync::Arc::clone(&rules);

    let network = Network::new();

    let (_wind_tx, mut wind_rx) = tokio::sync::mpsc::unbounded_channel::<sea::WindData>();

    // Task for centralized coordinator task work that is generated by the tasks implemented after this
    let (coord_tx, mut coord_rx) = tokio::sync::mpsc::unbounded_channel::<LighthouseTask>();
    let coord_tx_new_client = coord_tx.clone();
    tokio::spawn(async move {
        let coordinator = CoordinatorImpl::new(None).await;

        // unlock clients to send us stuff when all our expected clients are connected
        let total_clients_check_rats = std::sync::Arc::clone(&coordinator.rat_qs);
        let (clients_collected_tx, mut clients_collected_rx) = tokio::sync::mpsc::channel(1);
        tokio::spawn(async move {
            debug!("waiting for all clients to be connected");
            CoordinatorImpl::ensure_clients_connected(total_clients_check_rats.clone(), clients)
                .await;
            debug!("all clients connected, sending ack to clients.");
            clients_collected_tx.send(()).await.unwrap();
            let clients = total_clients_check_rats.read().await;
            let ack = sea::net::Packet {
                header: sea::net::Header::default(),
                data: sea::net::PacketKind::Acknowledge,
            };
            for (_client_name, client) in clients.iter() {
                match client.sender.send(ack.clone()).await {
                    Err(e) => {
                        error!("Could not send ack to unlock client: {e}");
                    }
                    Ok(_) => {}
                }
            }
        });

        let mut new_clients_chan = coordinator.sea.network_clients_chan.subscribe();
        // Spawn a task for each rat or wind to listen when variables come in
        // TODO maybe also await until clients are collected so we can remove this task since all tasks that are needed for long term have been spawned
        let lighthouse_client_connected = std::sync::Arc::new(std::sync::RwLock::new(false));
        let tasks_lh_connect = std::sync::Arc::clone(&lighthouse_client_connected);
        tokio::spawn(async move {
            loop {
                match new_clients_chan.recv().await {
                    Ok(client) => {
                        match client.name {
                            sea::ShipKind::Rat(name) => {
                                if name == COMPARE_NODE_NAME {
                                    let mut lock = tasks_lh_connect.write().unwrap();
                                    *lock = true;
                                    // TODO handle set false when disconnected
                                }
                                let mut client_news = client.recv.subscribe();
                                let inner_name = name.clone();
                                let rat_rules = rules.clone();
                                let rat_coord_tx = coord_tx_new_client.clone();
                                // spawn task to handle variable requests for this rat
                                tokio::spawn(async move {
                                    let lighthouse_name = COMPARE_NODE_NAME.to_string();
                                    loop {
                                        match client_news.recv().await {
                                            Ok((packet, _)) => {
                                                if let PacketKind::VariableTaskRequest(variable) =
                                                    packet.data
                                                {
                                                    let rat_rules_ref = rat_rules.read().unwrap();
                                                    let lighthouse_actions = sea::get_strategies(
                                                        &rat_rules_ref,
                                                        &lighthouse_name,
                                                        variable.clone(),
                                                        Some(&inner_name),
                                                    );

                                                    for action in lighthouse_actions {
                                                        if !matches!(action, ActionPlan::Sail) {
                                                            rat_coord_tx
                                                                .send(
                                                                    LighthouseTask::SendRatAction {
                                                                        ship_name: lighthouse_name
                                                                            .clone(),
                                                                        data: action,
                                                                    },
                                                                )
                                                                .unwrap();
                                                        }
                                                    }

                                                    let mut my_actions = sea::get_strategies(
                                                        &rat_rules_ref,
                                                        &inner_name,
                                                        variable.clone(),
                                                        None,
                                                    );

                                                    if my_actions.is_empty() {
                                                        my_actions.push(ActionPlan::Sail);
                                                    }

                                                    // answer the client that asked
                                                    for action in my_actions {
                                                        rat_coord_tx
                                                            .send(LighthouseTask::SendRatAction {
                                                                ship_name: inner_name.clone(),
                                                                data: action,
                                                            })
                                                            .unwrap();
                                                    }
                                                }
                                            }
                                            Err(e) => {
                                                warn!(
                                                    "Could not receive packet from client {inner_name}: {e}"
                                                );
                                                return;
                                            }
                                        }
                                    }
                                });
                            }
                            sea::ShipKind::Wind(_name) => {
                                // TODO WIND... needs to send to every wind that is added here via name, so we need a channel that awaits all expected winds (or currently connected but then its race condition) and this needs to be managed here. in the main code the wind can only be blown after all are connected
                                while let Some(data) = wind_rx.recv().await {
                                    for wind in network.winds.iter() {
                                        coord_tx_new_client
                                            .send(LighthouseTask::SendWind {
                                                ship_name: wind.name.clone(),
                                                data: data.clone(),
                                            })
                                            .unwrap();
                                    }
                                }
                            }
                        }
                    }
                    Err(e) => {
                        error!("Could not receive new client: {}", e);
                    }
                }
            }
        });

        // wait here until all clients are connected. TODO to select that reacts on ctrl-c and exits
        clients_collected_rx.recv().await;

        // save the broadcast channels for all clients here so they are subscribed before reactions to variables come in
        let clients = {
            let clients = coordinator.rat_qs.read().await;
            clients
                .iter()
                .map(|(name, _)| name.clone())
                .collect::<Vec<_>>()
        };
        let mut queues = HashMap::new();

        for client_name in clients.iter() {
            let q = coordinator
                .rat_action_request_queue(client_name.clone())
                .await;
            match q {
                Err(e) => {
                    error!("Could not get client queue: {e}");
                }
                Ok(queue_receiver) => {
                    queues.insert(client_name.clone(), queue_receiver);
                }
            }
        }

        let mut lock_next = false;
        while let Some(task) = coord_rx.recv().await {
            debug!("received coordinator task {:?}", task);
            match task {
                LighthouseTask::AppendRule { variable, commands } => {
                    let mut current_rules = rules_changer.write().unwrap();
                    current_rules.insert(variable, commands);
                }
                LighthouseTask::RulesClear => {
                    let mut current_rules = rules_changer.write().unwrap();
                    current_rules.clear();
                }
                LighthouseTask::LockNext => {
                    lock_next = true;
                }
                LighthouseTask::Unlock => {
                    let clients = coordinator.rat_qs.read().await;
                    for (c, _) in clients.iter() {
                        match coordinator
                            .rat_send(c.clone(), PacketKind::Acknowledge)
                            .await
                        {
                            Err(e) => {
                                error!("Error while sending ack for unlocking to Rat {}: {}", c, e);
                                std::process::exit(1);
                            }
                            Ok(_) => (),
                        }
                    }
                    lock_next = false;
                }
                LighthouseTask::SendWind { ship_name, data } => {
                    match coordinator.blow_wind(ship_name.clone(), data).await {
                        Err(e) => {
                            error!("Error while blowing wind to {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        _ => (),
                    }
                }
                LighthouseTask::SendRatAction {
                    ship_name,
                    mut data,
                } => {
                    {
                        let lh_connected = lighthouse_client_connected.read().unwrap();
                        if !*lh_connected {
                            if ship_name == COMPARE_NODE_NAME {
                                continue;
                            }
                            data = match &data {
                                ActionPlan::Sail => data.clone(),
                                ActionPlan::Shoot { target } => {
                                    let ntargets = target
                                        .into_iter()
                                        .cloned()
                                        .filter(|t| t != COMPARE_NODE_NAME)
                                        .collect::<Vec<_>>();
                                    if ntargets.is_empty() {
                                        ActionPlan::Sail
                                    } else {
                                        ActionPlan::Shoot { target: ntargets }
                                    }
                                }
                                ActionPlan::Catch { source } => {
                                    if source == COMPARE_NODE_NAME {
                                        ActionPlan::Sail
                                    } else {
                                        data.clone()
                                    }
                                }
                            };
                        }
                    }

                    let lock_next = if lock_next && ship_name != COMPARE_NODE_NAME {
                        true
                    } else {
                        false
                    };

                    match coordinator
                        .rat_action_send(ship_name.clone(), data, lock_next)
                        .await
                    {
                        Err(e) => {
                            error!("Error while sending action to Rat {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        Ok(_) => (),
                    }
                }
            }
        }
        debug!("coord_rx closed");
    });

    // Wind Sender Task

    // The bag reader is a different task that can be notified with a channel what to do
    //let bagfile = "bagfile";
    // TODO bag reader task, create random data for now, bagfile later!

    // let rand_imu = ImuMsg::default();
    // let imu_data = sea::WindData::Imu(rand_imu);
    // wind_tx.send(imu_data).unwrap();

    // let rand_points = vec![PointXYZ::new(1.0, 1.0, 1.0)];
    // let rand_points = PointCloud2Msg::try_from_vec(rand_points).unwrap();
    // let lidar_data = sea::WindData::Pointcloud(rand_points);
    // wind_tx.send(lidar_data).unwrap();

    tokio::select! {
        _ = tokio::signal::ctrl_c() => {
            info!("Ctrl-C received. Shutting down...");
            std::process::exit(0); // all dangling tokio processes etc will be killed by the os
            // TODO ignores dissolving network currently
        }
    }

    // Ok(())
}
