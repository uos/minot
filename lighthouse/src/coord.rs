use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::str::FromStr;

use log::{debug, error, info, warn};
use sea::{coordinator::CoordinatorImpl, net::PacketKind};

use rlc::{ActionPlan, COMPARE_NODE_NAME, Rules, VariableHistory};
use sea::{Coordinator, WindData};

#[derive(Debug)]
enum LighthouseTask {
    AppendRule {
        variable: String,
        commands: Vec<rlc::VariableHuman>,
    },
    LockNext,
    RulesClear,
    SendRatAction {
        ship_name: String,
        data: ActionPlan,
    },
    // TODO variables currently handled manually because of a async deadlock
    // GetVariableChannel {
    //     ship: String,
    //     answer: oneshot::Sender<broadcast::Receiver<String>>,
    // },
    SendWind {
        ship_name: String,
        data: sea::WindData,
    },
    WindDynamicVarReq(String), // Target is always LH TUI
    Unlock,
}

#[derive(Debug)]
enum WindTaskKind {
    Fix(Vec<WindData>),
    Dynamic,
}

#[derive(Debug)]
struct WindTask {
    kind: WindTaskKind,
    already_seen: bool,
}

#[tokio::main(flavor = "multi_thread")]
pub async fn main() -> anyhow::Result<()> {
    let env = env_logger::Env::new().filter_or("LH_LOG", "off");
    env_logger::Builder::from_env(env).init();

    // file can be rules or wind set by _wind var
    let filepath = std::env::args().nth(1);

    let eval = if let Some(fp) = filepath {
        let rules_file = PathBuf::from_str(&fp)?;
        let rules_file = std::fs::canonicalize(&rules_file)?;
        rlc::compile_file(&rules_file, None, None)?
    } else {
        rlc::Evaluated {
            rules: Rules::new(),
            wind: Vec::new(),
            vars: VariableHistory::new(Vec::new()),
        }
    };

    let rules = eval.rules;
    let mut clients = HashSet::new();

    // ships from rules
    for (_, inner_clients) in rules.raw().iter() {
        inner_clients.iter().for_each(|client| {
            clients.insert(client.ship.clone());
        });
    }

    // find all winds using variables
    let winds = eval.vars.resolve("_wind")?;
    let winds = if let Some(winds) = winds {
        match winds {
            rlc::Rhs::Array(items)
                if items.iter().all(|item| match **item {
                    rlc::Rhs::Val(rlc::Val::StringVal(_)) => true,
                    _ => false,
                }) =>
            {
                items
                    .into_iter()
                    .map(|item| match *item {
                        rlc::Rhs::Val(rlc::Val::StringVal(wind)) => wind,
                        _ => {
                            unreachable!("Catched in higher match.")
                        }
                    })
                    .collect::<Vec<_>>()
            }
            rlc::Rhs::Val(rlc::Val::StringVal(single_wind)) => {
                vec![single_wind]
            }
            _ => {
                return Err(anyhow::anyhow!(
                    "Expected _wind variable to be String or Array<String>"
                ));
            }
        }
    } else {
        vec![]
    };

    clients.extend(winds);

    // TODO On exit: disconnect all members of the network.
    // only use the rats that are mentioned. filter out the rest.
    // Winds are not mapped to rats, so they won't be filtered.

    let rules = std::sync::Arc::new(std::sync::RwLock::new(rules));
    let rules_changer = std::sync::Arc::clone(&rules);

    let winds_var = std::sync::Arc::new(std::sync::RwLock::new(HashMap::<String, WindTask>::new()));
    let winds_changer = std::sync::Arc::clone(&winds_var);

    let (wind_tx, _) = tokio::sync::broadcast::channel::<sea::WindData>(20); // TODO send on wind_tx

    // Task for centralized coordinator task work that is generated by the tasks implemented after this
    let (coord_tx, mut coord_rx) = tokio::sync::mpsc::unbounded_channel::<LighthouseTask>();
    let coord_tx_new_client = coord_tx.clone();
    tokio::spawn(async move {
        let coordinator = CoordinatorImpl::new(None).await;

        // unlock clients to send us stuff when all our expected clients are connected
        let total_clients_check_rats = std::sync::Arc::clone(&coordinator.rat_qs);
        let (clients_collected_tx, mut clients_collected_rx) = tokio::sync::mpsc::channel(1);
        tokio::spawn(async move {
            debug!("waiting for all clients to be connected");
            CoordinatorImpl::ensure_clients_connected(total_clients_check_rats.clone(), clients)
                .await;
            debug!("all clients connected, sending ack to clients.");
            clients_collected_tx.send(()).await.unwrap();
            let clients = total_clients_check_rats.read().await;
            let ack = sea::net::Packet {
                header: sea::net::Header::default(),
                data: sea::net::PacketKind::Acknowledge,
            };
            for (_client_name, client) in clients.iter() {
                match client.sender.send(ack.clone()).await {
                    Err(e) => {
                        error!("Could not send ack to unlock client: {e}");
                    }
                    Ok(_) => {}
                }
            }
        });

        let mut new_clients_chan = coordinator.sea.network_clients_chan.subscribe();
        // Spawn a task for each rat or wind to listen when variables come in
        // TODO maybe also await until clients are collected so we can remove this task since all tasks that are needed for long term have been spawned
        let lighthouse_client_connected = std::sync::Arc::new(std::sync::RwLock::new(false));
        let tasks_lh_connect = std::sync::Arc::clone(&lighthouse_client_connected);
        tokio::spawn(async move {
            loop {
                match new_clients_chan.recv().await {
                    Ok(client) => {
                        let wind_tx_inner = wind_tx.clone();
                        match client.name {
                            sea::ShipKind::Rat(name) => {
                                if name == COMPARE_NODE_NAME {
                                    let mut lock = tasks_lh_connect.write().unwrap();
                                    *lock = true;
                                    // TODO handle set false when disconnected
                                }
                                let mut client_news = client.recv.subscribe();
                                let inner_name = name.clone();
                                let rat_rules = rules.clone();
                                let rat_coord_tx = coord_tx_new_client.clone();
                                let winds_inner = std::sync::Arc::clone(&winds_changer);
                                // spawn task to handle variable requests for this rat
                                tokio::spawn(async move {
                                    let lighthouse_name = COMPARE_NODE_NAME.to_string();
                                    match inner_name.as_str() {
                                        COMPARE_NODE_NAME => loop {
                                            match client_news.recv().await {
                                                Ok((packet, _)) => match packet.data {
                                                    PacketKind::RuleAppend {
                                                        variable,
                                                        commands,
                                                    } => {
                                                        rat_coord_tx
                                                            .send(LighthouseTask::AppendRule {
                                                                variable,
                                                                commands,
                                                            })
                                                            .unwrap();
                                                    }
                                                    PacketKind::RulesClear => {
                                                        rat_coord_tx
                                                            .send(LighthouseTask::RulesClear)
                                                            .unwrap();
                                                    }
                                                    PacketKind::LockNext => {
                                                        rat_coord_tx
                                                            .send(LighthouseTask::LockNext)
                                                            .unwrap();
                                                    }
                                                    PacketKind::Unlock => {
                                                        rat_coord_tx
                                                            .send(LighthouseTask::Unlock)
                                                            .unwrap();
                                                    }
                                                    PacketKind::WindDynamic(var) => {
                                                        let mut w = winds_inner.write().unwrap();
                                                        if w.get(&var).is_none() {
                                                            w.insert(
                                                                var,
                                                                WindTask {
                                                                    already_seen: false,
                                                                    kind: WindTaskKind::Dynamic,
                                                                },
                                                            );
                                                        }
                                                    }
                                                    PacketKind::Wind {
                                                        data: wind_data,
                                                        at_var,
                                                    } => match at_var {
                                                        Some(var) => {
                                                            let mut w =
                                                                winds_inner.write().unwrap();
                                                            if let Some(wt) = w.get_mut(&var) {
                                                                match &mut wt.kind {
                                                                    WindTaskKind::Fix(
                                                                        wind_datas,
                                                                    ) => {
                                                                        wind_datas.push(wind_data);
                                                                    }
                                                                    _ => {}
                                                                }
                                                            } else {
                                                                w.insert(
                                                                    var,
                                                                    WindTask {
                                                                        already_seen: false,
                                                                        kind: WindTaskKind::Fix(
                                                                            vec![wind_data],
                                                                        ),
                                                                    },
                                                                );
                                                            }
                                                        }
                                                        None => {
                                                            let res = wind_tx_inner.send(wind_data);
                                                            if let Err(_) = res {
                                                                error!(
                                                                    "Could not send wind data to proxy sender. Are you sure the winds are connected?",
                                                                );
                                                            }
                                                        }
                                                    },

                                                    PacketKind::Heartbeat => {
                                                        debug!(
                                                            "Received Heartbeat from wind Lighthouse TUI."
                                                        );
                                                    }
                                                    _ => {
                                                        warn!(
                                                            "Received unexpected packet from Lighthouse TUI",
                                                            // packet.data
                                                        );
                                                    }
                                                },
                                                Err(e) => {
                                                    error!(
                                                        "Could not receive packet from client {inner_name}: {e}"
                                                    );
                                                    return;
                                                }
                                            }
                                        },
                                        _ => {
                                            loop {
                                                match client_news.recv().await {
                                                    Ok((packet, _)) => {
                                                        if let PacketKind::VariableTaskRequest(
                                                            variable,
                                                        ) = packet.data
                                                        {
                                                            let rat_rules_ref =
                                                                rat_rules.read().unwrap();
                                                            let lighthouse_actions =
                                                                sea::get_strategies(
                                                                    &rat_rules_ref,
                                                                    &lighthouse_name,
                                                                    variable.clone(),
                                                                    Some(&inner_name),
                                                                );

                                                            for action in lighthouse_actions {
                                                                if !matches!(
                                                                    action,
                                                                    ActionPlan::Sail
                                                                ) {
                                                                    rat_coord_tx
                                                                .send(
                                                                    LighthouseTask::SendRatAction {
                                                                        ship_name: lighthouse_name
                                                                            .clone(),
                                                                        data: action,
                                                                    },
                                                                )
                                                                .unwrap();
                                                                }
                                                            }

                                                            let mut my_actions =
                                                                sea::get_strategies(
                                                                    &rat_rules_ref,
                                                                    &inner_name,
                                                                    variable.clone(),
                                                                    None,
                                                                );

                                                            if my_actions.is_empty() {
                                                                my_actions.push(ActionPlan::Sail);
                                                            }

                                                            // answer the client that asked
                                                            for action in my_actions {
                                                                rat_coord_tx
                                                            .send(LighthouseTask::SendRatAction {
                                                                ship_name: inner_name.clone(),
                                                                data: action,
                                                            })
                                                            .unwrap();
                                                            }

                                                            let mut winds =
                                                                winds_inner.write().unwrap();

                                                            let mut changed = false;
                                                            winds.get_mut(&variable).map(|wt| {
                                                                if !wt.already_seen {
                                                                    match &mut wt.kind {
                                                                        WindTaskKind::Fix(
                                                                            wind_datas,
                                                                        ) => {
                                                                            wind_datas
                                                                                .iter()
                                                                                .for_each(
                                                                                    |wind_data| {
                                                                                        wind_tx_inner.send(wind_data.clone()).unwrap(); // Forward to each listener of newly connected winds. They resolve the names.
                                                                                    },
                                                                                );
                                                                            wt.already_seen = true;
                                                                            changed = true;
                                                                        }
                                                                        WindTaskKind::Dynamic => {
                                                                            // ask LH TUI to send the next fix command to us
                                                                            rat_coord_tx.send(LighthouseTask::WindDynamicVarReq(variable.clone())).unwrap();
                                                                        }
                                                                    }
                                                                }
                                                            });

                                                            // set all other to be sent again
                                                            if changed {
                                                                for (var, wind) in winds.iter_mut()
                                                                {
                                                                    if var == &variable {
                                                                        continue;
                                                                    }

                                                                    wind.already_seen = false;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    Err(e) => {
                                                        error!(
                                                            "Could not receive packet from client {inner_name}: {e}"
                                                        );
                                                        return;
                                                    }
                                                }
                                            }
                                        }
                                    };
                                });
                            }
                            sea::ShipKind::Wind(name) => {
                                let mut client_news = client.recv.subscribe();
                                let (acked_wind_tx, mut acked_wind_rx) =
                                    tokio::sync::mpsc::channel(5);
                                let inner_name_rx = name.clone();
                                tokio::spawn(async move {
                                    loop {
                                        match client_news.recv().await {
                                            Ok((packet, _)) => match packet.data {
                                                PacketKind::Acknowledge => {
                                                    if let Err(e) = acked_wind_tx.send(()).await {
                                                        error!(
                                                            "Could not passthrough ack trigger in wind receiver {inner_name_rx}: {e}"
                                                        );
                                                        return;
                                                    }
                                                }
                                                PacketKind::Heartbeat => {
                                                    debug!(
                                                        "Received Heartbeat from wind {inner_name_rx}."
                                                    );
                                                }
                                                _ => {
                                                    warn!(
                                                        "Unexpected packet from wind: {packet:?}"
                                                    );
                                                }
                                            },
                                            Err(e) => {
                                                error!(
                                                    "Could not receive packet from wind client {inner_name_rx}: {e}"
                                                );
                                                return;
                                            }
                                        }
                                    }
                                });
                                let inner_name = name.clone();
                                let wind_coord_tx = coord_tx_new_client.clone();
                                tokio::spawn(async move {
                                    let mut sub = wind_tx_inner.subscribe();
                                    while let Ok(data) = sub.recv().await {
                                        wind_coord_tx
                                            .send(LighthouseTask::SendWind {
                                                ship_name: inner_name.clone(),
                                                data,
                                            })
                                            .unwrap();
                                        _ = acked_wind_rx.recv().await.unwrap(); // wait for wind to have sent everything. TODO add feedback channel for LH so it knows when wind is available again
                                    }
                                });
                            }
                        }
                    }
                    Err(e) => {
                        error!("Could not receive new client: {}", e);
                    }
                }
            }
        });

        // wait here until all clients are connected. TODO to select that reacts on ctrl-c and exits
        clients_collected_rx.recv().await;

        // save the broadcast channels for all clients here so they are subscribed before reactions to variables come in
        let clients = {
            let clients = coordinator.rat_qs.read().await;
            clients
                .iter()
                .map(|(name, _)| name.clone())
                .collect::<Vec<_>>()
        };
        let mut queues = HashMap::new();

        for client_name in clients.iter() {
            let q = coordinator
                .rat_action_request_queue(client_name.clone())
                .await;
            match q {
                Err(e) => {
                    error!("Could not get client queue: {e}");
                }
                Ok(queue_receiver) => {
                    queues.insert(client_name.clone(), queue_receiver);
                }
            }
        }

        let mut lock_next = false;
        while let Some(task) = coord_rx.recv().await {
            match task {
                LighthouseTask::WindDynamicVarReq(var) => {
                    {
                        let lh_connected = lighthouse_client_connected.read().unwrap();
                        if !*lh_connected {
                            error!(
                                "Wants to ask LH TUI for wind for var {var} but is not connected."
                            );
                            continue;
                        }
                    }

                    let ret = coordinator
                        .rat_send(
                            COMPARE_NODE_NAME.to_owned(),
                            PacketKind::VariableTaskRequest(var),
                        )
                        .await;
                    if let Err(e) = ret {
                        error!("Could not send Dynamic Var Request to LH TUI: {e}");
                    }
                }
                LighthouseTask::AppendRule { variable, commands } => {
                    let mut current_rules = rules_changer.write().unwrap();
                    current_rules.insert(variable, commands);
                }
                LighthouseTask::RulesClear => {
                    let mut current_rules = rules_changer.write().unwrap();
                    current_rules.clear();
                }
                LighthouseTask::LockNext => {
                    lock_next = true;
                }
                LighthouseTask::Unlock => {
                    let clients = coordinator.rat_qs.read().await;
                    for (c, _) in clients.iter() {
                        match coordinator
                            .rat_send(c.clone(), PacketKind::Acknowledge)
                            .await
                        {
                            Err(e) => {
                                error!("Error while sending ack for unlocking to Rat {}: {}", c, e);
                                std::process::exit(1);
                            }
                            Ok(_) => (),
                        }
                    }
                    lock_next = false;
                }
                LighthouseTask::SendWind { ship_name, data } => {
                    match coordinator.blow_wind(ship_name.clone(), data).await {
                        Err(e) => {
                            error!("Error while blowing wind to {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        _ => (),
                    }
                }
                LighthouseTask::SendRatAction {
                    ship_name,
                    mut data,
                } => {
                    {
                        let lh_connected = lighthouse_client_connected.read().unwrap();
                        if !*lh_connected {
                            if ship_name == COMPARE_NODE_NAME {
                                continue;
                            }
                            data = match &data {
                                ActionPlan::Sail => data.clone(),
                                ActionPlan::Shoot { target } => {
                                    let ntargets = target
                                        .into_iter()
                                        .cloned()
                                        .filter(|t| t != COMPARE_NODE_NAME)
                                        .collect::<Vec<_>>();
                                    if ntargets.is_empty() {
                                        ActionPlan::Sail
                                    } else {
                                        ActionPlan::Shoot { target: ntargets }
                                    }
                                }
                                ActionPlan::Catch { source } => {
                                    if source == COMPARE_NODE_NAME {
                                        ActionPlan::Sail
                                    } else {
                                        data.clone()
                                    }
                                }
                            };
                        }
                    }

                    let lock_next = if lock_next && ship_name != COMPARE_NODE_NAME {
                        true
                    } else {
                        false
                    };

                    match coordinator
                        .rat_action_send(ship_name.clone(), data, lock_next)
                        .await
                    {
                        Err(e) => {
                            error!("Error while sending action to Rat {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        Ok(_) => (),
                    }
                }
            }
        }
        debug!("coord_rx closed");
    });

    // Wind Sender Task

    // The bag reader is a different task that can be notified with a channel what to do
    //let bagfile = "bagfile";
    // TODO bag reader task, create random data for now, bagfile later!

    // let rand_imu = ImuMsg::default();
    // let imu_data = sea::WindData::Imu(rand_imu);
    // wind_tx.send(imu_data).unwrap();

    // let rand_points = vec![PointXYZ::new(1.0, 1.0, 1.0)];
    // let rand_points = PointCloud2Msg::try_from_vec(rand_points).unwrap();
    // let lidar_data = sea::WindData::Pointcloud(rand_points);
    // wind_tx.send(lidar_data).unwrap();

    tokio::select! {
        _ = tokio::signal::ctrl_c() => {
            info!("Ctrl-C received. Shutting down...");
            return Ok(()) // all dangling tokio processes etc will be killed by the os
            // TODO ignores dissolving network currently
        }
    }
}
