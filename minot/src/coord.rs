use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::str::FromStr;

use anyhow::anyhow;
use log::{debug, error, info, warn};
use sea::net::Packet;
use sea::{coordinator::CoordinatorImpl, net::PacketKind};

use rlc::{ActionPlan, COMPARE_NODE_NAME, Rules, VariableHistory};
use sea::{Coordinator, WindData};

pub fn topic_from_eval_or_default(
    eval: &rlc::Evaluated,
    path: &str,
    default: &str,
) -> anyhow::Result<String> {
    let topic = eval.vars.resolve(path)?;
    if let Some(topic) = topic {
        match topic {
            rlc::Rhs::Path(topic) | rlc::Rhs::Val(rlc::Val::StringVal(topic)) => Ok(topic),
            _ => {
                return Err(anyhow!("Expected String or Path for sending lidar topic"));
            }
        }
    } else {
        Ok(default.to_owned())
    }
}

#[derive(Debug)]
enum MinotTask {
    AppendRule {
        variable: String,
        commands: Vec<rlc::VariableHuman>,
    },
    LockNext {
        unlock_first: bool,
    },
    RulesClear,
    SendRatAction {
        ship_name: String,
        data: ActionPlan,
    },
    SendWind {
        ship_name: String,
        data: Vec<sea::WindData>,
    },
    WindDynamicVarReq(String), // Target is always Minot TUI
    Unlock,
    RegisterShipAtVar {
        ship: String,
        var: String,
        kind: sea::net::RatPubRegisterKind,
    },
}

#[derive(Debug)]
enum WindTaskKind {
    Fix(Vec<WindData>),
    Dynamic,
}

#[derive(Debug)]
struct WindTask {
    kind: WindTaskKind,
    already_seen: bool,
}

pub fn run_coordinator(locked_start: bool, clients: HashSet<String>, rules: Rules) {
    let clients_wait_for_ack = std::sync::Arc::new(std::sync::RwLock::new(!clients.is_empty()));
    let rules = std::sync::Arc::new(std::sync::RwLock::new(rules));
    let rules_changer = std::sync::Arc::clone(&rules);

    let winds_var = std::sync::Arc::new(std::sync::RwLock::new(
        HashMap::<String, Vec<WindTask>>::new(),
    ));
    let winds_changer = std::sync::Arc::clone(&winds_var);

    let (wind_tx, _) = tokio::sync::broadcast::channel::<Vec<sea::WindData>>(20);

    // Task for centralized coordinator task work that is generated by the tasks implemented after this
    let (coord_tx, mut coord_rx) = tokio::sync::mpsc::unbounded_channel::<MinotTask>();
    let coord_tx_new_client = coord_tx.clone();
    let cwa_write = std::sync::Arc::clone(&clients_wait_for_ack);
    tokio::spawn(async move {
        let coordinator =
            std::sync::Arc::new(CoordinatorImpl::new(None, clients_wait_for_ack).await);

        // unlock clients to send us stuff when all our expected clients are connected
        let total_clients_check_rats = std::sync::Arc::clone(&coordinator.rat_qs);
        let (clients_collected_tx, mut clients_collected_rx) = tokio::sync::mpsc::channel(1);
        tokio::spawn(async move {
            debug!("waiting for all clients to be connected");
            CoordinatorImpl::ensure_clients_connected(total_clients_check_rats.clone(), clients)
                .await;
            debug!("all clients connected, sending ack to clients.");
            clients_collected_tx.send(()).await.unwrap();
            let clients = total_clients_check_rats.read().await;
            let ack = sea::net::Packet {
                header: sea::net::Header::default(),
                data: sea::net::PacketKind::Acknowledge,
            };
            for (_client_name, client) in clients.iter() {
                match client.sender.send(ack.clone()).await {
                    Err(e) => {
                        error!("Could not send ack to unlock client: {e}");
                    }
                    Ok(_) => {}
                }
            }
            // allow other clients to join after all predefined clients are connected
            let mut cwa = cwa_write.write().unwrap();
            *cwa = false;
        });

        let mut new_clients_chan = coordinator.sea.network_clients_chan.subscribe();
        // Spawn a task for each rat or wind to listen when variables come in
        // TODO maybe also await until clients are collected so we can remove this task since all tasks that are needed for long term have been spawned
        let minot_client_connected = std::sync::Arc::new(std::sync::RwLock::new(false));
        let tasks_minot_connect = std::sync::Arc::clone(&minot_client_connected);
        let rules_change_for_disconnect = std::sync::Arc::clone(&rules_changer);
        tokio::spawn(async move {
            loop {
                match new_clients_chan.recv().await {
                    Ok(client) => {
                        let wind_tx_inner = wind_tx.clone();
                        match client.name {
                            sea::ShipKind::Rat(name) => {
                                if name == COMPARE_NODE_NAME {
                                    let mut lock = tasks_minot_connect.write().unwrap();
                                    *lock = true;
                                    // TODO handle set false when disconnected
                                }
                                let mut client_news = client.recv.subscribe();
                                let inner_name = name.clone();
                                let rat_rules = rules.clone();
                                let rat_coord_tx = coord_tx_new_client.clone();
                                let winds_inner = std::sync::Arc::clone(&winds_changer);
                                let rules_change_for_disconnect_inner = std::sync::Arc::clone(&rules_change_for_disconnect);
                                // spawn task to handle variable requests for this rat
                                tokio::spawn(async move {
                                    let minot_compare_name = COMPARE_NODE_NAME.to_string();
                                    match inner_name.as_str() {
                                        COMPARE_NODE_NAME => loop {
                                            match client_news.recv().await {
                                                Ok((packet, _)) => match packet.data {
                                                    PacketKind::RuleAppend {
                                                        variable,
                                                        commands,
                                                    } => {
                                                        rat_coord_tx
                                                            .send(MinotTask::AppendRule {
                                                                variable,
                                                                commands,
                                                            })
                                                            .unwrap();
                                                    }
                                                    PacketKind::RulesClear => {
                                                        rat_coord_tx
                                                            .send(MinotTask::RulesClear)
                                                            .unwrap();
                                                    }
                                                    PacketKind::LockNext { unlock_first } => {
                                                        rat_coord_tx
                                                            .send(MinotTask::LockNext {
                                                                unlock_first,
                                                            })
                                                            .unwrap();
                                                    }
                                                    PacketKind::Unlock => {
                                                        rat_coord_tx
                                                            .send(MinotTask::Unlock)
                                                            .unwrap();
                                                    }
                                                    PacketKind::WindDynamic(var) => {
                                                        let mut w = winds_inner.write().unwrap();
                                                        let ty = WindTask {
                                                            already_seen: false,
                                                            kind: WindTaskKind::Dynamic,
                                                        };
                                                        match w.get_mut(&var) {
                                                            Some(wts) => {
                                                                wts.push(ty);
                                                            }
                                                            None => {
                                                                w.insert(var, vec![ty]);
                                                            }
                                                        }
                                                    }
                                                    PacketKind::Wind(bwd) => {
                                                        let mut send_now =
                                                            Vec::with_capacity(bwd.len());
                                                        for wd in bwd {
                                                            match wd.at_var {
                                                                Some(var) => {
                                                                    let mut w = winds_inner
                                                                        .write()
                                                                        .unwrap();
                                                                    match w.get_mut(&var) {
                                                                        Some(wt) => {
                                                                            wt.push(WindTask { kind: WindTaskKind::Fix(vec![wd.data]), already_seen: false });
                                                                        }
                                                                        None => {
                                                                            w.insert(var,
                                                                            vec![WindTask {
                                                                                already_seen: false,
                                                                                kind: WindTaskKind::Fix(vec![wd.data])
                                                                            }]);
                                                                        }
                                                                    }
                                                                }
                                                                None => {
                                                                    send_now.push(wd.data);
                                                                }
                                                            }
                                                        }

                                                        let res = wind_tx_inner.send(send_now);
                                                        if let Err(_) = res {
                                                            error!(
                                                                "Could not send wind data to proxy sender. Are you sure the winds are connected?",
                                                            );
                                                        }
                                                    }

                                                    PacketKind::Heartbeat => {
                                                        debug!(
                                                            "Received Heartbeat from wind Minot TUI."
                                                        );
                                                    }
                                                    _ => {
                                                        warn!(
                                                            "Received unexpected packet from Minot TUI",
                                                            // packet.data
                                                        );
                                                    }
                                                },
                                                Err(e) => {
                                                    error!(
                                                        "Could not receive packet from client {inner_name}: {e}"
                                                    );
                                                    return;
                                                }
                                            }
                                        },
                                        _ => {
                                            loop {
                                                match client_news.recv().await {
                                                    Ok((packet, _)) => {
                                                        match packet.data {
                                                            PacketKind::RegisterShipAtVar {
                                                                ship,
                                                                var,
                                                                kind,
                                                            } => {
                                                                rat_coord_tx.send(MinotTask::RegisterShipAtVar {ship,var,kind,},).unwrap();
                                                                client.send.send(Packet {header: sea::net::Header::default(),data: PacketKind::Acknowledge,}).await.unwrap();
                                                            }
                                                            PacketKind::VariableTaskRequest(
                                                                variable,
                                                            ) => {
                                                                let rat_rules_ref =
                                                                    rat_rules.read().unwrap();
                                                                let minot_actions =
                                                                    sea::get_strategies(
                                                                        &rat_rules_ref,
                                                                        &minot_compare_name,
                                                                        variable.clone(),
                                                                        Some(&inner_name),
                                                                    );

                                                                for action in minot_actions {
                                                                    if !matches!(
                                                                        action,
                                                                        ActionPlan::Sail
                                                                    ) {
                                                                        rat_coord_tx.send(
                                                                    MinotTask::SendRatAction {
                                                                        ship_name: minot_compare_name
                                                                            .clone(),
                                                                        data: action,
                                                                    },
                                                                )
                                                                .unwrap();
                                                                    }
                                                                }

                                                                let mut my_actions =
                                                                    sea::get_strategies(
                                                                        &rat_rules_ref,
                                                                        &inner_name,
                                                                        variable.clone(),
                                                                        None,
                                                                    );

                                                                if my_actions.is_empty() {
                                                                    my_actions
                                                                        .push(ActionPlan::Sail);
                                                                }

                                                                debug!("sending actions: {:?}", my_actions);

                                                                // answer the client that asked
                                                                for action in my_actions {
                                                                    rat_coord_tx.send(MinotTask::SendRatAction {
                                                                        ship_name: inner_name.clone(),
                                                                        data: action,
                                                                    })
                                                                    .unwrap();
                                                                }

                                                                let mut winds =
                                                                    winds_inner.write().unwrap();

                                                                let mut asked_for_dynamic = false;
                                                                winds.get_mut(&variable).map(|wt| {
                                                                    wt.iter_mut().for_each(|wte| {
                                                                        // TODO we saved many reguests here for the same var but only one will come through "already seen"
                                                                        if !wte.already_seen {
                                                                            match &mut wte.kind {
                                                                                WindTaskKind::Fix(wind_datas) => {
                                                                                        let ret = wind_tx_inner.send(wind_datas.clone()); // Forward to each listener of newly connected winds. They resolve the names.
                                                                                        match ret {
                                                                                            Ok(_) => {},
                                                                                            Err(e) => {
                                                                                                error!("Could not reach any turbine. Are you sure you have started and connected any? {e}");
                                                                                            },
                                                                                        }
                                                                                }
                                                                                WindTaskKind::Dynamic => {
                                                                                    if asked_for_dynamic {
                                                                                        wte.already_seen = true;
                                                                                        return; // only ask one time dynamic for the variable because minot tui sends all winds for this var with one request
                                                                                    }
                                                                                    asked_for_dynamic = true;

                                                                                    info!("asking Minot TUI for dyn for {}", &variable);
                                                                                    // ask Minot TUI to send the next fix command to us
                                                                                    let ret = rat_coord_tx.send(MinotTask::WindDynamicVarReq(variable.clone()));
                                                                                    match ret {
                                                                                        Ok(_) => {},
                                                                                        Err(e) => {
                                                                                            error!("Could not find connected Minot TUI for asking dynamic wind. {e}");
                                                                                        },
                                                                                    }
                                                                                }
                                                                            };
                                                                            wte.already_seen = true;
                                                                        }
                                                                    });
                                                                });

                                                                // set all other to be sent again
                                                                for (var, wind) in
                                                                    winds.iter_mut()
                                                                {
                                                                    if var == &variable {
                                                                        continue;
                                                                    }

                                                                    wind.iter_mut().for_each(
                                                                        |wte| {
                                                                            wte.already_seen =
                                                                                false;
                                                                        },
                                                                    );
                                                                }
                                                            }
                                                            PacketKind::Heartbeat => {}

                                                            _ => {
                                                                warn!(
                                                                    "Received unexpected packet {:?}",
                                                                    packet.data
                                                                );
                                                            }
                                                        }
                                                    }
                                                    Err(e) => {
                                                        match e {
                                                            tokio::sync::broadcast::error::RecvError::Closed => {
                                                                // disconnecting from network
                                                                if client.remove_rules_on_disconnect {
                                                                    let mut current_rules = rules_change_for_disconnect_inner.write().unwrap();
                                                                    current_rules.remove_client(&inner_name);
                                                                }
                                                            }, 
                                                            _ => {
                                                                error!(
                                                                    "Could not receive packet from client {inner_name}: {e}"
                                                                );
                                                            }
                                                        }
                                                        return;
                                                    }
                                                }
                                            }
                                        }
                                    };
                                });
                            }
                            sea::ShipKind::Wind(name) => {
                                let mut client_news = client.recv.subscribe();
                                let (acked_wind_tx, mut acked_wind_rx) =
                                    tokio::sync::mpsc::channel(5);
                                let inner_name_rx = name.clone();
                                tokio::spawn(async move {
                                    loop {
                                        match client_news.recv().await {
                                            Ok((packet, _)) => match packet.data {
                                                PacketKind::Acknowledge => {
                                                    if let Err(e) = acked_wind_tx.send(()).await {
                                                        error!(
                                                            "Could not passthrough ack trigger in wind receiver {inner_name_rx}: {e}"
                                                        );
                                                        return;
                                                    }
                                                }
                                                PacketKind::Heartbeat => {
                                                    debug!(
                                                        "Received Heartbeat from wind {inner_name_rx}."
                                                    );
                                                }
                                                _ => {
                                                    warn!(
                                                        "Unexpected packet from wind: {packet:?}"
                                                    );
                                                }
                                            },
                                            Err(e) => {
                                                match e {
                                                    tokio::sync::broadcast::error::RecvError::Closed => {}, // disconnected from network
                                                    _ => {
                                                        error!(
                                                            "Could not receive packet from wind client {inner_name_rx}: {e}"
                                                        );
                                                    }
                                                }
                                                return;
                                            }
                                        }
                                    }
                                });
                                let inner_name = name.clone();
                                let wind_coord_tx = coord_tx_new_client.clone();
                                tokio::spawn(async move {
                                    let mut sub = wind_tx_inner.subscribe();
                                    info!("Started wind forwarding for turbine: {}", &inner_name);
                                    while let Ok(data) = sub.recv().await {
                                        wind_coord_tx
                                            .send(MinotTask::SendWind {
                                                ship_name: inner_name.clone(),
                                                data,
                                            })
                                            .unwrap();
                                        _ = acked_wind_rx.recv().await.unwrap(); // wait for wind to have sent everything. TODO add feedback channel for LH so it knows when wind is available again
                                    }
                                });
                            }
                        }
                    }
                    Err(e) => {
                        error!("Could not receive new client: {}", e);
                    }
                }
            }
        });

        // wait here until all clients are connected.
        clients_collected_rx.recv().await;

        let mut lock_next = locked_start;
        while let Some(task) = coord_rx.recv().await {
            match task {
                MinotTask::WindDynamicVarReq(var) => {
                    {
                        let minot_tui_connected = minot_client_connected.read().unwrap();
                        if !*minot_tui_connected {
                            error!(
                                "Wants to ask Minot TUI for wind for var {var} but is not connected."
                            );
                            continue;
                        }
                    }

                    let ret = coordinator
                        .rat_send(
                            COMPARE_NODE_NAME.to_owned(),
                            PacketKind::VariableTaskRequest(var),
                        )
                        .await;
                    if let Err(e) = ret {
                        error!("Could not send Dynamic Var Request to LH TUI: {e}");
                    }
                }
                MinotTask::AppendRule { variable, commands } => {
                    let mut current_rules = rules_changer.write().unwrap();
                    current_rules.insert(variable, commands);
                    info!("added new rule");
                }
                MinotTask::RulesClear => {
                    let mut current_rules = rules_changer.write().unwrap();
                    current_rules.clear();
                    info!("cleared all rules");
                }
                MinotTask::LockNext { unlock_first } => {
                    info!("locking next");
                    if unlock_first {
                        let clients = coordinator.rat_qs.read().await;
                        for (c, _) in clients.iter() {
                            match coordinator
                                .rat_send(c.clone(), PacketKind::Acknowledge)
                                .await
                            {
                                Err(e) => {
                                    error!(
                                        "Error while sending ack for unlocking to Rat {}: {}",
                                        c, e
                                    );
                                    std::process::exit(1);
                                }
                                Ok(_) => (),
                            }
                        }
                    }

                    lock_next = true;
                }
                MinotTask::Unlock => {
                    let clients = coordinator.rat_qs.read().await;
                    for (c, _) in clients.iter() {
                        match coordinator
                            .rat_send(c.clone(), PacketKind::Acknowledge)
                            .await
                        {
                            Err(e) => {
                                error!("Error while sending ack for unlocking to Rat {}: {}", c, e);
                                std::process::exit(1);
                            }
                            Ok(_) => (),
                        }
                    }
                    lock_next = false;
                }
                MinotTask::SendWind { ship_name, data } => {
                    match coordinator.blow_wind(ship_name.clone(), data).await {
                        Err(e) => {
                            error!("Error while blowing wind to {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        _ => (),
                    }
                }
                MinotTask::SendRatAction {
                    ship_name,
                    mut data,
                } => {
                    {
                        let minot_tui_connected = minot_client_connected.read().unwrap();
                        if !*minot_tui_connected {
                            if ship_name == COMPARE_NODE_NAME {
                                continue;
                            }
                            data = match &data {
                                ActionPlan::Sail => data.clone(),
                                ActionPlan::Shoot { target, id } => {
                                    let ntargets = target
                                        .into_iter()
                                        .cloned()
                                        .filter(|t| t != COMPARE_NODE_NAME)
                                        .collect::<Vec<_>>();
                                    if ntargets.is_empty() {
                                        ActionPlan::Sail
                                    } else {
                                        ActionPlan::Shoot { target: ntargets, id: *id,}
                                    }
                                }
                                ActionPlan::Catch { source, id: _ } => {
                                    if source == COMPARE_NODE_NAME {
                                        ActionPlan::Sail
                                    } else {
                                        data.clone()
                                    }
                                }
                            };
                        }
                    }

                    let lock_next = if lock_next && ship_name != COMPARE_NODE_NAME {
                        true
                    } else {
                        false
                    };

                    match coordinator
                        .rat_action_send(ship_name.clone(), data, lock_next)
                        .await
                    {
                        Err(e) => {
                            error!("Error while sending action to Rat {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        Ok(_) => (),
                    }
                }
                MinotTask::RegisterShipAtVar { ship, var, kind } => {
                    let mut current_rules = rules_changer.write().unwrap();
                    info!("Registering for topics {:?}", (&ship, &var, &kind));
                    current_rules.register(
                        var,
                        ship,
                        match kind {
                            sea::net::RatPubRegisterKind::Publish => {
                                rlc::RatPubRegisterKind::Publish
                            }
                            sea::net::RatPubRegisterKind::Subscribe => {
                                rlc::RatPubRegisterKind::Subscribe
                            }
                        },
                    );
                }
            }
        }
        debug!("coord_rx closed");
    });
}

pub fn get_clients(eval: &rlc::Evaluated) -> anyhow::Result<HashSet<String>> {
    let mut clients = HashSet::new();

    // ships from rules
    for (_, inner_clients) in eval.rules.raw().iter() {
        inner_clients.iter().for_each(|client| {
            if let Some(strat) = &client.strategy {
                match strat {
                    ActionPlan::Sail => {}
                    ActionPlan::Shoot { target, id: _ } => {
                        clients.extend(target.clone());
                    }
                    ActionPlan::Catch { source, id: _ } => {
                        clients.insert(source.clone());
                    }
                }
            };
            clients.insert(client.ship.clone());
        });
    }

    // find all winds using variables
    let winds = eval.vars.resolve("_wind")?;
    let winds = if let Some(winds) = winds {
        match winds {
            rlc::Rhs::Array(items)
                if items.iter().all(|item| match **item {
                    rlc::Rhs::Val(rlc::Val::StringVal(_)) => true,
                    _ => false,
                }) =>
            {
                items
                    .into_iter()
                    .map(|item| match *item {
                        rlc::Rhs::Val(rlc::Val::StringVal(wind)) => wind,
                        _ => {
                            unreachable!("Catched in higher match.")
                        }
                    })
                    .collect::<Vec<_>>()
            }
            rlc::Rhs::Val(rlc::Val::StringVal(single_wind)) => {
                vec![single_wind]
            }
            _ => {
                return Err(anyhow::anyhow!(
                    "Expected _wind variable to be String or Array<String>"
                ));
            }
        }
    } else {
        vec![]
    };

    clients.extend(winds);

    Ok(clients)
}

#[tokio::main(flavor = "multi_thread")]
pub async fn main() -> anyhow::Result<()> {
    let env = env_logger::Env::new().filter_or("RUST_LOG", "info");
    env_logger::Builder::from_env(env).init();

    // file can be rules or wind set by _wind var
    let filepath = std::env::args().nth(1);

    let eval = if let Some(fp) = filepath {
        let rules_file = PathBuf::from_str(&fp)?;
        let rules_file = std::fs::canonicalize(&rules_file)?;
        rlc::compile_file(&rules_file, None, None)?
    } else {
        rlc::Evaluated {
            rules: Rules::new(),
            wind: Vec::new(),
            vars: VariableHistory::new(Vec::new()),
        }
    };

    let locked_start = eval.vars.resolve("_start_locked")?;
    let locked_start = if let Some(rhs) = locked_start {
        match rhs {
            rlc::Rhs::Val(rlc::Val::BoolVal(locked)) => Ok(locked),
            _ => Err(anyhow!("Expected bool for _start_locked.")),
        }
    } else {
        Ok(false)
    }?;

    let clients = get_clients(&eval)?;
    run_coordinator(locked_start, clients, eval.rules);

    tokio::select! {
        _ = tokio::signal::ctrl_c() => {
            info!("Ctrl-C received. Shutting down...");
            return Ok(()) // all dangling tokio processes etc will be killed by the os
            // TODO ignores dissolving network currently
        }
    }
}
