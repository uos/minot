use std::collections::{HashMap, HashSet};

use log::{debug, error, info, warn};
// use ros_pointcloud2::{points::PointXYZ, PointCloud2Msg};
use sea::{
    coordinator::CoordinatorImpl,
    net::PacketKind,
    // ImuMsg,
};

struct Wind {
    pub name: String,
}

struct Network {
    winds: Vec<Wind>,
}

impl Network {
    fn new() -> Self {
        Network { winds: Vec::new() }
    }
}

// #[derive(Debug, Copy, Clone)]
// enum BagReaderTask {
//     LidarFrame(u32),
//     OdomFrame(u32),
//     MixedWhile(f64), // Time in seconds
//                      // More here like "mixed until n lidar" or "random out of sync" etc
// }

// All possible variables that should be acted on must be known beforehand.
// They get an ID or get generated into a type? TODO
// ID => VariableRule
// hashmap[string] => ID
// ID => VariableRule

use sea::Coordinator;

#[derive(Debug)]
enum CoordinatorTask {
    // TODO variables currently handled manually because of a async deadlock
    // GetVariableChannel {
    //     ship: String,
    //     answer: oneshot::Sender<broadcast::Receiver<String>>,
    // },
    SendWind {
        ship_name: String,
        data: sea::WindData,
    },
    SendRatAction {
        ship_name: String,
        data: sea::ActionPlan,
    },
}

#[tokio::main(flavor = "multi_thread")]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let mut pairs = HashMap::new();
    pairs.insert(
        "var1".to_string(),
        (
            sea::VariableHuman {
                ship: "testRat1".to_string(),
                strategy: Some(sea::ActionPlan::Shoot {
                    target: vec!["testRat2".to_string()],
                }),
            },
            sea::VariableHuman {
                ship: "testRat2".to_string(),
                strategy: Some(sea::ActionPlan::Catch {
                    source: "testRat1".to_string(),
                }),
            },
        ),
    );

    pairs.insert(
        "var3".to_string(),
        (
            sea::VariableHuman {
                ship: "testRat2".to_string(),
                strategy: Some(sea::ActionPlan::Shoot {
                    target: vec!["testRat1".to_string()],
                }),
            },
            sea::VariableHuman {
                ship: "testRat1".to_string(),
                strategy: Some(sea::ActionPlan::Catch {
                    source: "testRat2".to_string(),
                }),
            },
        ),
    );

    let mut clients = HashSet::new();
    for (_, (p1, p2)) in pairs.iter() {
        clients.insert(p1.ship.clone());
        clients.insert(p2.ship.clone());
    }

    // TODO parse config/ratlang and see if all mentioned rats are registered
    // err and exit if not.
    // On exit: disconnect all members of the network.
    // only use the rats that are mentioned. filter out the rest.
    // Winds are not mapped to rats, so they won't be filtered.

    let pairs = std::sync::Arc::new(pairs);

    let network = Network::new();

    let (_wind_tx, mut wind_rx) = tokio::sync::mpsc::unbounded_channel::<sea::WindData>();

    // Task for centralized coordinator task work that is generated by the tasks implemented after this
    let (coord_tx, mut coord_rx) = tokio::sync::mpsc::unbounded_channel::<CoordinatorTask>();
    let coord_tx_new_client = coord_tx.clone();
    tokio::spawn(async move {
        let coordinator = CoordinatorImpl::new(None).await;

        // unlock clients to send us stuff when all our expected clients are connected
        let total_clients_check_rats = std::sync::Arc::clone(&coordinator.rat_qs);
        let (clients_collected_tx, mut clients_collected_rx) = tokio::sync::mpsc::channel(1);
        tokio::spawn(async move {
            debug!("waiting for all clients to be connected");
            CoordinatorImpl::ensure_clients_connected(total_clients_check_rats.clone(), clients)
                .await;
            debug!("all clients connected, sending ack to clients.");
            clients_collected_tx.send(()).await.unwrap();
            let clients = total_clients_check_rats.read().await;
            let ack = sea::net::Packet {
                header: sea::net::Header::default(),
                data: sea::net::PacketKind::Acknowledge,
            };
            for (_client_name, client) in clients.iter() {
                match client.sender.send(ack.clone()).await {
                    Err(e) => {
                        error!("Could not send ack to unlock client: {e}");
                    }
                    Ok(_) => {}
                }
            }
        });

        let mut new_clients_chan = coordinator.sea.network_clients_chan.subscribe();
        // let coord_tx_new_client = coord_tx.clone();
        // Spawn a task for each rat or wind to listen when variables come in
        // TODO maybe also await until clients are collected so we can remove this task since all tasks that are needed for long term have been spawned
        tokio::spawn(async move {
            loop {
                match new_clients_chan.recv().await {
                    Ok(client) => match client.name {
                        sea::ShipKind::Rat(name) => {
                            let mut client_news = client.recv.subscribe();
                            let inner_name = name.clone();
                            let rat_pairs = pairs.clone();
                            let rat_coord_tx = coord_tx_new_client.clone();
                            // spawn task to handle variable requests for this rat
                            tokio::spawn(async move {
                                loop {
                                    match client_news.recv().await {
                                        Ok((packet, _)) => {
                                            if let PacketKind::VariableTaskRequest(variable) =
                                                packet.data
                                            {
                                                let action = sea::get_strategy(
                                                    &rat_pairs,
                                                    &inner_name,
                                                    variable,
                                                );
                                                rat_coord_tx
                                                    .send(CoordinatorTask::SendRatAction {
                                                        ship_name: inner_name.clone(),
                                                        data: action,
                                                    })
                                                    .unwrap();
                                            }
                                        }
                                        Err(e) => {
                                            warn!("Could not receive packet from client {inner_name}: {e}");
                                            return;
                                        }
                                    }
                                }
                            });
                        }
                        sea::ShipKind::Wind(_name) => {
                            // TODO WIND... needs to send to every wind that is added here via name, so we need a channel that awaits all expected winds (or currently connected but then its race condition) and this needs to be managed here. in the main code the wind can only be blown after all are connected
                            while let Some(data) = wind_rx.recv().await {
                                for wind in network.winds.iter() {
                                    coord_tx_new_client
                                        .send(CoordinatorTask::SendWind {
                                            ship_name: wind.name.clone(),
                                            data: data.clone(),
                                        })
                                        .unwrap();
                                }
                            }
                        }
                        sea::ShipKind::God => {
                            error!("Other coordinator connected to this coordinator.");
                            return;
                        }
                    },
                    Err(e) => {
                        error!("Could not receive new client: {}", e);
                    }
                }
            }
        });

        // wait here until all clients are connected. TODO to select that reacts on ctrl-c and exits
        clients_collected_rx.recv().await;

        // save the broadcast channels for all clients here so they are subscribed before reactions to variables come in
        let clients = {
            let clients = coordinator.rat_qs.read().await;
            clients
                .iter()
                .map(|(name, _)| name.clone())
                .collect::<Vec<_>>()
        };
        let mut queues = HashMap::new();

        for client_name in clients.iter() {
            let q = coordinator
                .rat_action_request_queue(client_name.clone())
                .await;
            match q {
                Err(e) => {
                    error!("Could not get client queue: {e}");
                }
                Ok(queue_receiver) => {
                    queues.insert(client_name.clone(), queue_receiver);
                }
            }
        }

        debug!("waiting for coordinate_receiver channel");
        while let Some(task) = coord_rx.recv().await {
            debug!("received coordinator task {:?}", task);
            match task {
                // CoordinatorTask::GetVariableChannel { ship, answer } => {
                //     let queue = queues
                //         .get(&ship)
                //         .expect("Unknown client, should be connected before sending here.");

                //     answer.send(queue.resubscribe()).unwrap();
                // }
                CoordinatorTask::SendWind { ship_name, data } => {
                    match coordinator.blow_wind(ship_name.clone(), data).await {
                        Err(e) => {
                            error!("Error while blowing wind to {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        _ => (),
                    }
                }
                CoordinatorTask::SendRatAction { ship_name, data } => {
                    match coordinator.rat_action_send(ship_name.clone(), data).await {
                        Err(e) => {
                            error!("Error while sending action to Rat {}: {}", ship_name, e);
                            std::process::exit(1);
                        }
                        Ok(_) => (),
                    }
                }
            }
        }
        debug!("coord_rx closed");
    });

    // Wind Sender Task

    // The bag reader is a different task that can be notified with a channel what to do
    //let bagfile = "bagfile";
    // TODO bag reader task, create random data for now, bagfile later!

    // let rand_imu = ImuMsg::default();
    // let imu_data = sea::WindData::Imu(rand_imu);
    // wind_tx.send(imu_data).unwrap();

    // let rand_points = vec![PointXYZ::new(1.0, 1.0, 1.0)];
    // let rand_points = PointCloud2Msg::try_from_vec(rand_points).unwrap();
    // let lidar_data = sea::WindData::Pointcloud(rand_points);
    // wind_tx.send(lidar_data).unwrap();

    tokio::select! {
        _ = tokio::signal::ctrl_c() => {
            info!("Ctrl-C received. Shutting down...");
            std::process::exit(0); // all dangling tokio processes etc will be killed by the os
            // TODO ignores dissolving network currently
        }
    }

    // Ok(())
}
